AWSTemplateFormatVersion: 2010-09-09
Description: 'Deployes hasura ecs service for existing RDS and VPC'
Parameters:
  APIName:
    Description: The name of the ECS Service.
    Type: String
    Default: 'HasuraGraphQLAPI-<CHANGE_ME>'
  DBEndpoint:
    Description: 'The endpoint for PostgreSQL'
    Type: String
    Default: 'devpostgres.cvde1gulz0vk.us-west-1.rds.amazonaws.com'
  DBUsername:
    Description: 'The username that will be used for the root admin user in PostgreSQL'
    Type: String
    Default: 'hastest1'
  DBUserPassword:
    Description: 'The password that will be used alongside the root admin username'
    Type: String
    Default: '!hastest!'
  DBName:
    Description: 'The name of the PostgreSQL database'
    Type: String
    Default: 'hastest1'
  DockerImage:
    Description: 'Name and tag of the Hasura Docker Image'
    Type: String
    Default: 'hasura/graphql-engine:v2.24.1'
  ContainerPort:
    Description: 'Hasura exposes stuff over 8080. We need to tell this to the container definition.'
    Type: Number
    Default: 8080
  LoadBalancerPort:
    Description: 'The load balancer accepts traffic on the port 80.'
    Type: Number
    Default: 80
  HealthCheckPath:
    Description: 'The Health check path. Hasura exposes /healthz as a health check path. Used on the LoadBalancing Target group.'
    Type: String
    Default: /healthz
  MinContainers:
    Description: 'for autoscaling'
    Type: Number
    Default: 1
  MaxContainers:
    Description: 'for autoscaling'
    Type: Number
    Default: 10
  AutoScalingTargetValue:
    Description: 'target CPU utilization (%)'
    Type: Number
    Default: 80
  HasuraAdminSecret:
    Description: 'The haasura console should have an access key for basic security.'
    Type: String

  VpcId:
    Type: AWS::EC2::VPC::Id
    Description: VPC that has access to the postgres db
    Default: 'vpc-0813c9d5475677cd8'
  VpcPublicSubnetA:
    Type: AWS::EC2::Subnet::Id
    Description: List of 2 public SubnetIds for the given VPC.
    Default: 'subnet-00fd2a34adb9fbfeb'
  VpcPublicSubnetB:
    Type: AWS::EC2::Subnet::Id
    Description: 'B'
    Default: 'subnet-0628998114fa9b80f'
  VpcPrivateSubnetA:
    Type: AWS::EC2::Subnet::Id
    Description: List of 2 private SubnetIds for the given VPC.
    Default: 'subnet-0e1edb91d06782376'
  VpcPrivateSubnetB:
    Type: AWS::EC2::Subnet::Id
    Description: 'B'
    Default: 'subnet-0f2e3ae9b28fa4da2'
  RDSSecurityGroupID:
    Type: AWS::EC2::SecurityGroup::Id
    Description: 'ID of RDS security group that will be modified to allow access on 5432 port'
    Default: 'sg-078d62d647307abf4'
  HasuraJWTSSecret:
    Type: String
    Description: 'HASURA_GRAPHQL_JWT_SECRET value'
    Default: ''

Conditions:
  IsEnvEmpty:  !Equals [ "HasuraJWTSSecret", ""]

Resources:

  #I'm listing security groups in the order that traffic would flow from the outside internet. It would first come through the SSL port 443 on the load balancer.
  #This first security group should be assigned to any load balancer that is sitting in front of an EC2 instance in the VPC
  #https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group.html
  LoadBalancerSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupName: !Sub '${APIName}-ELB-SecurityGroup'
      GroupDescription: !Sub 'Security group to control external access to the load balancer. ${APIName}'
      VpcId: !Ref 'VpcId'
      SecurityGroupIngress:
        - IpProtocol: 'tcp'
          FromPort: 443
          ToPort: 443
          CidrIp: '0.0.0.0/0'
        - IpProtocol: 'tcp'
          FromPort: 80
          ToPort: 80
          CidrIp: '0.0.0.0/0'
        - IpProtocol: 'tcp'
          FromPort: 443
          ToPort: 443
          CidrIpv6: '::/0'
        - IpProtocol: 'tcp'
          FromPort: 80
          ToPort: 80
          CidrIpv6: '::/0'
      Tags:
        - Key: 'Name'
          Value: !Sub '${APIName}-ELB-SecurityGroup'
  #After traffic comes in through a load balancer it goes to an EC2 instance. The EC2 instance should allow traffic from the load balancer over both port 80 and 8080 which are two common ports.
  EC2SecurityGroup:
    Type: 'AWS::EC2::SecurityGroup'
    Properties:
      GroupName: !Sub '${APIName}-EC2-SecurityGroup'
      GroupDescription: !Sub 'Security group to control access to an EC2 instance inside the ${APIName} stack VPC'
      VpcId: !Ref 'VpcId'
      SecurityGroupIngress:
        - IpProtocol: 'tcp'
          SourceSecurityGroupId: !Ref 'LoadBalancerSecurityGroup'
          FromPort: 8080
          ToPort: 8080
        - IpProtocol: 'tcp'
          SourceSecurityGroupId: !Ref 'LoadBalancerSecurityGroup'
          FromPort: 80
          ToPort: 80
      Tags:
        - Key: 'Name'
          Value: !Sub '${APIName}-EC2-SecurityGroup'

  Cluster:
    Type: AWS::ECS::Cluster
    Properties:
      ClusterName: !Join ['-', [!Ref APIName, Cluster]]
  #https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ecs-taskdefinition.html
  TaskDefinition:
    Type: AWS::ECS::TaskDefinition
    # Makes sure the log group is created before it is used.
    DependsOn: LogGroup
    Properties:
      # Name of the task definition. Subsequent versions of the task definition are grouped together under this name.
      Family: !Join ['-', [!Ref APIName, TaskDefinition]]
      # awsvpc is required for Fargate
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - FARGATE
      # 256 (.25 vCPU) - Available memory values: 0.5GB, 1GB, 2GB
      # 512 (.5 vCPU) - Available memory values: 1GB, 2GB, 3GB, 4GB
      # 1024 (1 vCPU) - Available memory values: 2GB, 3GB, 4GB, 5GB, 6GB, 7GB, 8GB
      # 2048 (2 vCPU) - Available memory values: Between 4GB and 16GB in 1GB increments
      # 4096 (4 vCPU) - Available memory values: Between 8GB and 30GB in 1GB increments
      Cpu: 512
      # 0.5GB, 1GB, 2GB - Available cpu values: 256 (.25 vCPU)
      # 1GB, 2GB, 3GB, 4GB - Available cpu values: 512 (.5 vCPU)
      # 2GB, 3GB, 4GB, 5GB, 6GB, 7GB, 8GB - Available cpu values: 1024 (1 vCPU)
      # Between 4GB and 16GB in 1GB increments - Available cpu values: 2048 (2 vCPU)
      # Between 8GB and 30GB in 1GB increments - Available cpu values: 4096 (4 vCPU)
      Memory: 1GB
      # A role needed by ECS.
      # "The ARN of the task execution role that containers in this task can assume. All containers in this task are granted the permissions that are specified in this role."
      # "There is an optional task execution IAM role that you can specify with Fargate to allow your Fargate tasks to make API calls to Amazon ECR."
      ExecutionRoleArn: !Ref ExecutionRole
      # "The Amazon Resource Name (ARN) of an AWS Identity and Access Management (IAM) role that grants containers in the task permission to call AWS APIs on your behalf."
      TaskRoleArn: !Ref TaskRole
      ContainerDefinitions:
        - Name: !Ref APIName
          Image: !Ref DockerImage
          PortMappings:
            - ContainerPort: !Ref ContainerPort
          # Send logs to CloudWatch Logs
          Environment:
            - Name: 'HASURA_GRAPHQL_DATABASE_URL'
              #Make the PostgreSQL connection string from the parameters we have.
              Value:
                !Join [
                  '',
                  [
                    'postgres://',
                    !Ref 'DBUsername',
                    ':',
                    !Ref 'DBUserPassword',
                    '@',
                    !Ref 'DBEndpoint',
                    ':5432/',
                    !Ref 'DBName',
                  ],
                ]
            - Name: 'HASURA_GRAPHQL_ENABLE_CONSOLE'
              Value: 'true'
            - Name: 'HASURA_GRAPHQL_ENABLED_LOG_TYPES'
              Value: 'startup, http-log, webhook-log, websocket-log, query-log'
            - Name: 'HASURA_GRAPHQL_ADMIN_SECRET'
              Value: !Ref 'HasuraAdminSecret'
            - Name: 'HASURA_GRAPHQL_DEV_MODE'
              Value: 'true'
            - Name: 'HASURA_GRAPHQL_METADATA_DEFAULTS'
              Value: "{\"backend_configs\":{\"dataconnector\":{\"athena\":{\"uri\":\"http://data-connector-agent:8081/api/v1/athena\"},\"mariadb\":{\"uri\":\"http://data-connector-agent:8081/api/v1/mariadb\"},\"mysql8\":{\"uri\":\"http://data-connector-agent:8081/api/v1/mysql\"},\"oracle\":{\"uri\":\"http://data-connector-agent:8081/api/v1/oracle\"},\"snowflake\":{\"uri\":\"http://data-connector-agent:8081/api/v1/snowflake\"}}}}"
            - !If
              - "IsEnvEmpty"
              - Name: "HASURA_GRAPHQL_JWT_SECRET"
                Value: !Ref 'HasuraJWTSSecret'
              - !Ref "AWS::NoValue"
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-region: !Ref AWS::Region
              awslogs-group: !Ref LogGroup
              awslogs-stream-prefix: ecs
  # A role needed by ECS
  ExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Join ['-', [!Ref APIName, ExecutionRole]]
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com
            Action: 'sts:AssumeRole'
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy'
  # A role for the containers
  TaskRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Join ['-', [!Ref APIName, TaskRole]]
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com
            Action: 'sts:AssumeRole'
  # A role needed for auto scaling
  AutoScalingRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Join ['-', [!Ref APIName, AutoScalingRole]]
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com
            Action: 'sts:AssumeRole'
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/service-role/AmazonEC2ContainerServiceAutoscaleRole'
  Service:
    Type: AWS::ECS::Service
    # This dependency is needed so that the load balancer is setup correctly in time
    DependsOn:
      - ListenerHTTP
    Properties:
      ServiceName: !Ref APIName
      Cluster: !Ref Cluster
      TaskDefinition: !Ref TaskDefinition
      DeploymentConfiguration:
        MinimumHealthyPercent: 100
        MaximumPercent: 200
      DesiredCount: 1
      # This may need to be adjusted if the container takes a while to start up
      HealthCheckGracePeriodSeconds: 120
      LaunchType: FARGATE
      NetworkConfiguration:
        AwsvpcConfiguration:
          # change to DISABLED if you're using private subnets that have access to a NAT gateway
          AssignPublicIp: DISABLED
          Subnets:
            - !Ref 'VpcPrivateSubnetA'
            - !Ref 'VpcPrivateSubnetB'
          SecurityGroups:
            - !Ref 'EC2SecurityGroup'
      LoadBalancers:
        - ContainerName: !Ref APIName
          ContainerPort: !Ref ContainerPort
          TargetGroupArn: !Ref TargetGroup
  TargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      HealthCheckIntervalSeconds: 10
      # will look for a 200 status code by default unless specified otherwise
      HealthCheckPath: !Ref HealthCheckPath
      HealthCheckTimeoutSeconds: 5
      UnhealthyThresholdCount: 2
      HealthyThresholdCount: 2
      Name: !Join ['-', [!Ref APIName, tg]]
      Port: !Ref ContainerPort
      Protocol: HTTP
      TargetGroupAttributes:
        - Key: deregistration_delay.timeout_seconds
          Value: 60 # default is 300
      TargetType: ip
      VpcId: !Ref VpcId
  ListenerHTTP:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      DefaultActions:
        - TargetGroupArn: !Ref TargetGroup
          Type: forward
      LoadBalancerArn: !Ref LoadBalancer
      Port: !Ref LoadBalancerPort
      Protocol: HTTP
  LoadBalancer:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      LoadBalancerAttributes:
        # this is the default, but is specified here in case it needs to be changed
        - Key: idle_timeout.timeout_seconds
          Value: 360
      Name: !Join ['-', [!Ref APIName, LoadBalancer]]
      # "internal" is also an option
      Scheme: internet-facing
      SecurityGroups:
        - !Ref 'LoadBalancerSecurityGroup'
      Subnets:
        - !Ref 'VpcPublicSubnetA'
        - !Ref 'VpcPublicSubnetB'
  LogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Join ['', [/ecs/, !Ref APIName, TaskDefinition]]
  AutoScalingTarget:
    Type: AWS::ApplicationAutoScaling::ScalableTarget
    Properties:
      MinCapacity: !Ref MinContainers
      MaxCapacity: !Ref MaxContainers
      ResourceId: !Join ['/', [service, !Ref Cluster, !GetAtt Service.Name]]
      ScalableDimension: ecs:service:DesiredCount
      ServiceNamespace: ecs
      # "The Amazon Resource Name (ARN) of an AWS Identity and Access Management (IAM) role that allows Application Auto Scaling to modify your scalable target."
      RoleARN: !GetAtt AutoScalingRole.Arn
  # allow access to RDS
  SecurityGroupRDSIngress:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !Ref 'RDSSecurityGroupID'
      IpProtocol: "tcp"
      ToPort: "5432"
      FromPort: "5432"
      SourceSecurityGroupId: !GetAtt EC2SecurityGroup.GroupId

  AutoScalingPolicy:
    Type: AWS::ApplicationAutoScaling::ScalingPolicy
    Properties:
      PolicyName: !Join ['-', [!Ref APIName, AutoScalingPolicy]]
      PolicyType: TargetTrackingScaling
      ScalingTargetId: !Ref AutoScalingTarget
      TargetTrackingScalingPolicyConfiguration:
        PredefinedMetricSpecification:
          PredefinedMetricType: ECSServiceAverageCPUUtilization
        ScaleInCooldown: 10
        ScaleOutCooldown: 10
        # Keep things at or lower than 50% CPU utilization, for example
        TargetValue: !Ref AutoScalingTargetValue


Outputs:
  AZA:
    Description: 'AZ of A'
    Value: !Select [0, !GetAZs '']
    Export:
      Name: !Sub '${AWS::StackName}-AZA'
  EC2SecurityGroupID:
    Description: 'The ID of the EC2 Security group'
    Value: !GetAtt EC2SecurityGroup.GroupId
    Export:
      Name: !Sub '${AWS::StackName}-EC2-ID'
