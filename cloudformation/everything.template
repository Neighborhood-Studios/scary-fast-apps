#!AWSTemplateFormat
AWSTemplateFormatVersion: 2010-09-09
Description: 'Deployes hasura ecs service for existing RDS and VPC'
Parameters:
  APIName:
    Description: The name of the ECS Service. Main Prefix.
    Type: String
    Default: 'SFA-<CHANGE_ME>'

  DBEndpoint:
    Description: 'The endpoint for PostgreSQL'
    Type: String
    Default: 'devpostgres.cvde1gulz0vk.us-west-1.rds.amazonaws.com'
  DBUsername:
    Description: 'The username that will be used for the root admin user in PostgreSQL'
    Type: String
    Default: 'hastest1'
  DBUserPassword:
    Description: 'The password that will be used alongside the root admin username'
    Type: String
    Default: '!hastest!'
  DBName:
    Description: 'The name of the PostgreSQL database'
    Type: String
    Default: 'hastest1'

  HasuraDockerImage:
    Description: 'Name and tag of the Hasura Docker Image'
    Type: String
    Default: 'hasura/graphql-engine:v2.24.1'

  HasuraContainerPort:
    # this can be hardcoded...
    Description: 'Hasura container exposes stuff over 8080. We need to tell this to the container definition.'
    Type: Number
    Default: 8080
  DjangoContainerPort:
    # this can be hardcoded...
    Description: 'Django container exposes stuff over 8080. We need to tell this to the container definition.'
    Type: Number
    Default: 8080

  InternalLoadBalancerHasuraPort:
    Description: 'The load balancer accepts traffic on the port 1001 and forwards to hasura.'
    Type: Number
    Default: 1001
  InternalLoadBalancerDjangoPort:
    Description: 'The load balancer accepts traffic on the port 1002 and forwards to django.'
    Type: Number
    Default: 1002

  HasuraHealthCheckPath:
    Description: 'The Health check path. Hasura exposes /healthz as a health check path. Used on the LoadBalancing Target group.'
    Type: String
    Default: /healthz
  MinContainers:
    Description: 'for autoscaling'
    Type: Number
    Default: 1
  MaxContainers:
    Description: 'for autoscaling'
    Type: Number
    Default: 10
  AutoScalingTargetValue:
    Description: 'target CPU utilization (%)'
    Type: Number
    Default: 80
  HasuraAdminSecret:
    Description: 'The haasura console should have an access key for basic security.'
    Type: String

  VpcId:
    Type: AWS::EC2::VPC::Id
    Description: VPC that has access to the postgres db
    Default: 'vpc-0813c9d5475677cd8'
  VpcCIDR:
    Type: String
    Description: "VPC's CIDR"
    Default: '10.20.0.0/16'
  VpcPublicSubnetA:
    Type: AWS::EC2::Subnet::Id
    Description: List of 2 public SubnetIds for the given VPC.
    Default: 'subnet-00fd2a34adb9fbfeb'
  VpcPublicSubnetB:
    Type: AWS::EC2::Subnet::Id
    Description: 'B'
    Default: 'subnet-0628998114fa9b80f'
  VpcPrivateSubnetA:
    Type: AWS::EC2::Subnet::Id
    Description: List of 2 private SubnetIds for the given VPC.
    Default: 'subnet-0e1edb91d06782376'
  VpcPrivateSubnetB:
    Type: AWS::EC2::Subnet::Id
    Description: 'B'
    Default: 'subnet-0f2e3ae9b28fa4da2'
  RDSSecurityGroupID:
    Type: AWS::EC2::SecurityGroup::Id
    Description: 'ID of RDS security group that will be modified to allow access on 5432 port'
    Default: 'sg-078d62d647307abf4'
  HasuraJWTSSecret:
    Type: String
    Description: 'HASURA_GRAPHQL_JWT_SECRET value'
    Default: ''

Conditions:
  IsEnvEmpty:  !Equals [ "HasuraJWTSSecret", ""]

Resources:

  LoadBalancerSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupName: !Sub '${APIName}-ELB-SecurityGroup'
      GroupDescription: !Sub 'Security group to control external access to the load balancer. ${APIName}'
      VpcId: !Ref 'VpcId'
      SecurityGroupIngress:
        - IpProtocol: 'tcp'
          FromPort: 1000
          ToPort: 2000
          CidrIp: '0.0.0.0/0'
      Tags:
        - Key: 'Name'
          Value: !Sub '${APIName}-ELB-SecurityGroup'

  #After traffic comes in through a load balancer it goes to an EC2 instance. The EC2 instance should allow traffic from the load balancer over both port 80 and 8080 which are two common ports.
  EC2SecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupName: !Sub '${APIName}-EC2-SecurityGroup'
      GroupDescription: !Sub 'Security group to control access to an EC2 instances inside the ${APIName} stack VPC'
      VpcId: !Ref 'VpcId'
      SecurityGroupIngress:
        - IpProtocol: 'tcp'
          SourceSecurityGroupId: !Ref LoadBalancerSecurityGroup
          FromPort: 8080
          ToPort: 8080
          Description: "dunno, probably does nothing"
        - IpProtocol: 'tcp'
          CidrIp: !Ref VpcCIDR  # why? because NLB has no security group, at all, direct ip or cidr allowance only...
          FromPort: 8080
          ToPort: 8080
          Description: "container ports access for NLB"
      Tags:
        - Key: 'Name'
          Value: !Sub '${APIName}-EC2-SecurityGroup'

  # A role needed by ECS
  ECSExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Join ['-', [!Ref APIName, ExecutionRole]]
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com
            Action: 'sts:AssumeRole'
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy'
  # A role for the containers
  ECSTaskRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Join ['-', [!Ref APIName, TaskRole]]
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com
            Action: 'sts:AssumeRole'

  # A role needed for autoscaling
  AutoScalingRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Join ['-', [!Ref APIName, AutoScalingRole]]
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com
            Action: 'sts:AssumeRole'
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/service-role/AmazonEC2ContainerServiceAutoscaleRole'

  NetworkLoadBalancer:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
#      LoadBalancerAttributes:
#        - Key: idle_timeout.timeout_seconds  # not applicable to NLB
#          Value: 360
      Name: !Join ['-', [!Ref APIName, LoadBalancer]]
      Scheme: internal  # no public ips here
      Type: network
#      SecurityGroups:
#        - !Ref 'LoadBalancerSecurityGroup'
      Subnets:
        - !Ref 'VpcPrivateSubnetA'
        - !Ref 'VpcPrivateSubnetB'

  ECSCluster:
    Type: AWS::ECS::Cluster
    Properties:
      ClusterName: !Join ['-', [!Ref APIName, Cluster]]

  HasuraLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Join ['', [/ecs/, !Ref APIName, HasuraTaskDefinition]]

  #https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ecs-taskdefinition.html
  HasuraTaskDefinition:
    Type: AWS::ECS::TaskDefinition
    # Makes sure the log group is created before it is used.
    DependsOn: HasuraLogGroup
    Properties:
      # Name of the task definition. Subsequent versions of the task definition are grouped together under this name.
      Family: !Join ['-', [!Ref APIName, HasuraTaskDefinition]]
      # awsvpc is required for Fargate
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - FARGATE
      # 256 (.25 vCPU) - Available memory values: 0.5GB, 1GB, 2GB
      # 512 (.5 vCPU) - Available memory values: 1GB, 2GB, 3GB, 4GB
      # 1024 (1 vCPU) - Available memory values: 2GB, 3GB, 4GB, 5GB, 6GB, 7GB, 8GB
      # 2048 (2 vCPU) - Available memory values: Between 4GB and 16GB in 1GB increments
      # 4096 (4 vCPU) - Available memory values: Between 8GB and 30GB in 1GB increments
      Cpu: 512
      # 0.5GB, 1GB, 2GB - Available cpu values: 256 (.25 vCPU)
      # 1GB, 2GB, 3GB, 4GB - Available cpu values: 512 (.5 vCPU)
      # 2GB, 3GB, 4GB, 5GB, 6GB, 7GB, 8GB - Available cpu values: 1024 (1 vCPU)
      # Between 4GB and 16GB in 1GB increments - Available cpu values: 2048 (2 vCPU)
      # Between 8GB and 30GB in 1GB increments - Available cpu values: 4096 (4 vCPU)
      Memory: 1GB
      # A role needed by ECS.
      # "The ARN of the task execution role that containers in this task can assume. All containers in this task are granted the permissions that are specified in this role."
      # "There is an optional task execution IAM role that you can specify with Fargate to allow your Fargate tasks to make API calls to Amazon ECR."
      ExecutionRoleArn: !Ref ECSExecutionRole
      # "The Amazon Resource Name (ARN) of an AWS Identity and Access Management (IAM) role that grants containers in the task permission to call AWS APIs on your behalf."
      TaskRoleArn: !Ref ECSTaskRole
      ContainerDefinitions:
        - Name: !Join ['-', [!Ref APIName, hasura-container]]
          Image: !Ref HasuraDockerImage
          PortMappings:
            - ContainerPort: !Ref HasuraContainerPort
          # Send logs to CloudWatch Logs
          Environment:
            - Name: 'HASURA_GRAPHQL_DATABASE_URL'
              #Make the PostgreSQL connection string from the parameters we have.
              Value:
                !Join [
                  '',
                  [
                    'postgres://',
                    !Ref 'DBUsername',
                    ':',
                    !Ref 'DBUserPassword',
                    '@',
                    !Ref 'DBEndpoint',
                    ':5432/',
                    !Ref 'DBName',
                  ],
                ]
            - Name: 'HASURA_GRAPHQL_ENABLE_CONSOLE'
              Value: 'true'
            - Name: 'HASURA_GRAPHQL_ENABLED_LOG_TYPES'
              Value: 'startup, http-log, webhook-log, websocket-log, query-log'
            - Name: 'HASURA_GRAPHQL_ADMIN_SECRET'
              Value: !Ref 'HasuraAdminSecret'
            - Name: 'HASURA_GRAPHQL_DEV_MODE'
              Value: 'true'
            - Name: 'HASURA_GRAPHQL_METADATA_DEFAULTS'
              Value: "{\"backend_configs\":{\"dataconnector\":{\"athena\":{\"uri\":\"http://data-connector-agent:8081/api/v1/athena\"},\"mariadb\":{\"uri\":\"http://data-connector-agent:8081/api/v1/mariadb\"},\"mysql8\":{\"uri\":\"http://data-connector-agent:8081/api/v1/mysql\"},\"oracle\":{\"uri\":\"http://data-connector-agent:8081/api/v1/oracle\"},\"snowflake\":{\"uri\":\"http://data-connector-agent:8081/api/v1/snowflake\"}}}}"
            - !If
              - "IsEnvEmpty"
              - Name: "HASURA_GRAPHQL_JWT_SECRET"
                Value: !Ref 'HasuraJWTSSecret'
              - !Ref "AWS::NoValue"
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-region: !Ref AWS::Region
              awslogs-group: !Ref HasuraLogGroup
              awslogs-stream-prefix: ecs

  HasuraService:
    Type: AWS::ECS::Service
    # This dependency is needed so that the load balancer is setup correctly in time
    DependsOn:
      - NetworkLoadBalancer
      - HasuraNLBListener
      - HasuraTargetGroup
    Properties:
      ServiceName: !Ref APIName
      Cluster: !Ref ECSCluster
      TaskDefinition: !Ref HasuraTaskDefinition
      DeploymentConfiguration:
        MinimumHealthyPercent: 100
        MaximumPercent: 200
        DeploymentCircuitBreaker:
          Enable: true
          Rollback: true
      DesiredCount: 1
      # This may need to be adjusted if the container takes a while to start up
      HealthCheckGracePeriodSeconds: 120
      LaunchType: FARGATE
      NetworkConfiguration:
        AwsvpcConfiguration:
          # change to DISABLED if you're using private subnets that have access to a NAT gateway
          AssignPublicIp: DISABLED
          Subnets:
            - !Ref 'VpcPrivateSubnetA'
            - !Ref 'VpcPrivateSubnetB'
          SecurityGroups:
            - !Ref 'EC2SecurityGroup'
      LoadBalancers:
        - ContainerName: !Join ['-', [!Ref APIName, hasura-container]]
          ContainerPort: !Ref HasuraContainerPort
          TargetGroupArn: !Ref HasuraTargetGroup

  HasuraTargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    DependsOn: NetworkLoadBalancer
    Properties:
      Name: !Join ['-', [!Ref APIName, tg]]
      Protocol: TCP
      Port: !Ref HasuraContainerPort
      HealthCheckIntervalSeconds: 10
      # will look for a 200 status code by default unless specified otherwise
      HealthCheckProtocol: HTTP
      HealthCheckPath: !Ref HasuraHealthCheckPath
      HealthCheckTimeoutSeconds: 5
      UnhealthyThresholdCount: 2
      HealthyThresholdCount: 2
      TargetGroupAttributes:
        - Key: deregistration_delay.timeout_seconds
          Value: 60 # default is 300
      TargetType: ip
      VpcId: !Ref VpcId

  HasuraNLBListener:
    # Description: "listener that forwards TCP connections from InternalLoadBalancerHasuraPort to to ECS hasura container target"
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      DefaultActions:
        - TargetGroupArn: !Ref HasuraTargetGroup
          Type: forward
      LoadBalancerArn: !Ref NetworkLoadBalancer
      Port: !Ref InternalLoadBalancerHasuraPort
      Protocol: TCP


  # FIXME: this autoscaling thingi does not work...?!
  HasuraAutoScalingTarget:
    Type: AWS::ApplicationAutoScaling::ScalableTarget
    Properties:
      MinCapacity: !Ref MinContainers
      MaxCapacity: !Ref MaxContainers
      ResourceId: !Join ['/', [service, !Ref ECSCluster, !GetAtt HasuraService.Name]]
      ScalableDimension: ecs:service:DesiredCount
      ServiceNamespace: ecs
      # "The Amazon Resource Name (ARN) of an AWS Identity and Access Management (IAM) role that allows Application Auto Scaling to modify your scalable target."
      RoleARN: !GetAtt AutoScalingRole.Arn

  # FIXME: this autoscaling thingi does not work...?!
  AutoScalingPolicy:
    Type: AWS::ApplicationAutoScaling::ScalingPolicy
    Properties:
      PolicyName: !Join ['-', [!Ref APIName, AutoScalingPolicy]]
      PolicyType: TargetTrackingScaling
      ScalingTargetId: !Ref HasuraAutoScalingTarget
      TargetTrackingScalingPolicyConfiguration:
        PredefinedMetricSpecification:
          PredefinedMetricType: ECSServiceAverageCPUUtilization
        ScaleInCooldown: 10
        ScaleOutCooldown: 10
        # Keep things at or lower than 50% CPU utilization, for example
        TargetValue: !Ref AutoScalingTargetValue

  DjangoTargetGroup:
    Type: 'AWS::ElasticLoadBalancingV2::TargetGroup'
    Properties:
      Name: !Join [ '-', [ !Ref APIName, djtg ] ]
      Port: !Ref DjangoContainerPort
      Protocol: TCP
      HealthCheckIntervalSeconds: 10
      # will look for a 200 status code by default unless specified otherwise
      HealthCheckProtocol: HTTP
      HealthCheckPath: "/healthz"
      HealthCheckTimeoutSeconds: 5
      UnhealthyThresholdCount: 2
      HealthyThresholdCount: 2
      TargetGroupAttributes:
        - Key: deregistration_delay.timeout_seconds
          Value: 60 # default is 300
      TargetType: ip
      VpcId: !Ref VpcId

  DjangoNLBListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      DefaultActions:
        - TargetGroupArn: !Ref DjangoTargetGroup
          Type: forward
      LoadBalancerArn: !Ref NetworkLoadBalancer
      Port: !Ref InternalLoadBalancerDjangoPort
      Protocol: TCP

  DjangoECSService:
    Type: AWS::ECS::Service
    DependsOn:
      - NetworkLoadBalancer
      - DjangoNLBListener
      - DjangoTargetGroup
    Properties:
      Cluster: !Ref ECSCluster
      CapacityProviderStrategy:
        - CapacityProvider: FARGATE
          Base: 0
          Weight: 1
      # TODO: add definition to cf
      TaskDefinition: 'arn:aws:ecs:us-west-1:232267884965:task-definition/djangoApp:1'
      ServiceName: djangoApp
      SchedulingStrategy: REPLICA
      DesiredCount: 1
      LoadBalancers:
        - ContainerName: djangoApp
          ContainerPort: !Ref DjangoContainerPort
          TargetGroupArn: !Ref DjangoTargetGroup

      NetworkConfiguration:
        AwsvpcConfiguration:
          # change to DISABLED if you're using private subnets that have access to a NAT gateway
          AssignPublicIp: DISABLED
          Subnets:
            - !Ref 'VpcPrivateSubnetA'
            - !Ref 'VpcPrivateSubnetB'
          SecurityGroups:
            - !Ref 'EC2SecurityGroup'
      PlatformVersion: LATEST
      DeploymentConfiguration:
        MaximumPercent: 200
        MinimumHealthyPercent: 100
        DeploymentCircuitBreaker:
          Enable: true
          Rollback: true
      DeploymentController:
        Type: ECS
      ServiceConnectConfiguration:
        Enabled: false
      Tags: []
      EnableECSManagedTags: true

  # punch SG to allow access to RDS from ECS
  SecurityGroupRDSIngress:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !Ref RDSSecurityGroupID
      IpProtocol: "tcp"
      ToPort: "5432"
      FromPort: "5432"
      SourceSecurityGroupId: !GetAtt EC2SecurityGroup.GroupId

  # no the API GW...
  NLBVpcLink:
    Type: AWS::ApiGateway::VpcLink
    DependsOn:
      - NetworkLoadBalancer
    Properties:
      Name: !Sub '${APIName}-NLB-RandomLink'
      TargetArns:
        - !Ref NetworkLoadBalancer


  # Our simple CORS compliant REST API
  SimpleAPI:
    Type: 'AWS::ApiGateway::RestApi'
    Properties:
      Description: A simple CORS compliant API
      Name: !Ref APIName
      EndpointConfiguration:
        Types:
          - REGIONAL

  # The Resource (/api/) of our API
  SimpleAPIHasuraResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      ParentId: !GetAtt
        - SimpleAPI
        - RootResourceId
      PathPart: api
      RestApiId: !Ref SimpleAPI

  # The Resource (/da/) of our API
  SimpleAPIDjangoResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      ParentId: !GetAtt
        - SimpleAPI
        - RootResourceId
      PathPart: da
      RestApiId: !Ref SimpleAPI


  # The method to call for our API
  ELBAPIHasuraMethod:
    Type: AWS::ApiGateway::Method
    #checkov:skip=CKV_AWS_59: "This API does not expose backend service"
    Properties:
      ApiKeyRequired: false
      AuthorizationType: NONE
      HttpMethod: ANY
      OperationName: ELBProxyHasura
      Integration:
        Type: HTTP_PROXY
        Uri: !Sub "http://${NetworkLoadBalancer.DNSName}:${InternalLoadBalancerHasuraPort}"
        ConnectionType: VPC_LINK
        ConnectionId: !Ref NLBVpcLink
        IntegrationHttpMethod: ANY
        PassthroughBehavior: WHEN_NO_MATCH
      RestApiId: !Ref SimpleAPI
      ResourceId: !Ref SimpleAPIHasuraResource
    DependsOn:
      - NLBVpcLink

  # The method to call for our API
  ELBAPIDjangoMethod:
    Type: AWS::ApiGateway::Method
    #checkov:skip=CKV_AWS_59: "This API does not expose backend service"
    Properties:
      ApiKeyRequired: false
      AuthorizationType: NONE
      HttpMethod: ANY
      OperationName: ELBProxyDjango
      Integration:
        Type: HTTP_PROXY
        Uri: !Sub "http://${NetworkLoadBalancer.DNSName}:${InternalLoadBalancerDjangoPort}"
        ConnectionType: VPC_LINK
        ConnectionId: !Ref NLBVpcLink
        IntegrationHttpMethod: ANY
        PassthroughBehavior: WHEN_NO_MATCH
      RestApiId: !Ref SimpleAPI
      ResourceId: !Ref SimpleAPIHasuraResource
    DependsOn:
      - NLBVpcLink

  # A deployment resource for deploying our API
  APIDeployment:
    Type: 'AWS::ApiGateway::Deployment'
    DependsOn:
      - ELBAPIHasuraMethod
      - ELBAPIDjangoMethod
    Properties:
      RestApiId: !Ref SimpleAPI
      StageName: v1


  # The Amazon S3 bucket into which access logs from S3 (for the application) and CloudFront will be put
  LoggingBucket:
    #checkov:skip=CKV_AWS_18: "This bucket is private and only for storing logs"
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub 'react-cors-spa-${SimpleAPI}-logs'
      PublicAccessBlockConfiguration:
        BlockPublicAcls : true
        BlockPublicPolicy : true
        IgnorePublicAcls : true
        RestrictPublicBuckets : true
      VersioningConfiguration:
        Status: Enabled
      BucketEncryption:
        ServerSideEncryptionConfiguration:
        - ServerSideEncryptionByDefault:
            SSEAlgorithm: 'AES256'
      OwnershipControls:
        Rules:
          - ObjectOwnership: BucketOwnerPreferred
    DeletionPolicy: Delete

  # The Amazon S3 bucket into which our Single Page Application build files must be deployed
  S3Bucket:
    Type: AWS::S3::Bucket
    DeletionPolicy: Delete
    Properties:
      BucketName: !Sub 'react-cors-spa-${SimpleAPI}'
      PublicAccessBlockConfiguration:
        BlockPublicAcls : true
        BlockPublicPolicy : true
        IgnorePublicAcls : true
        RestrictPublicBuckets : true
      LoggingConfiguration:
        DestinationBucketName: !Ref LoggingBucket
        LogFilePrefix: s3-access-logs
      VersioningConfiguration:
        Status: Enabled
      BucketEncryption:
        ServerSideEncryptionConfiguration:
        - ServerSideEncryptionByDefault:
            SSEAlgorithm: 'AES256'

  # The Amazon S3 bucket policy for securing the bucket hosting the application
  BucketPolicy:
    Type: 'AWS::S3::BucketPolicy'
    Properties:
      PolicyDocument:
        Id: MyPolicy
        Version: 2012-10-17
        Statement:
          - Sid: PolicyForCloudFrontPrivateContent
            Effect: Allow
            Resource: !Sub ${S3Bucket.Arn}/*
            Principal:
              Service: cloudfront.amazonaws.com
            Condition:
              StringEquals:
                AWS:SourceArn: !Sub arn:aws:cloudfront::${AWS::AccountId}:distribution/${CFDistribution}
            Action: 's3:GetObject*'
      Bucket: !Ref S3Bucket

  # The Amazon CloudFront distribution exposing our Single Page Application
  CFDistribution:
    #checkov:skip=CKV_AWS_68: "For demo purposes and to reduce cost, no WAF is configured"
    Type: AWS::CloudFront::Distribution
    Properties:
      DistributionConfig:
        Origins:
        - DomainName: !GetAtt S3Bucket.RegionalDomainName
          Id: !Sub "${APIName}S3Origin"
          S3OriginConfig:
            OriginAccessIdentity: ""
          OriginAccessControlId: !GetAtt CloudFrontOriginAccessControl.Id
        - DomainName: !Sub "${SimpleAPI}.execute-api.${AWS::Region}.amazonaws.com"
          Id: !Sub "${APIName}APIGTWOrigin"
          CustomOriginConfig:
            OriginProtocolPolicy: https-only
        Enabled: 'true'
        DefaultRootObject: index.html
        DefaultCacheBehavior:
          AllowedMethods:
          - GET
          - HEAD
          - OPTIONS
          TargetOriginId: !Sub "${APIName}S3Origin"
          CachePolicyId: 658327ea-f89d-4fab-a63d-7e88639e58f6 # CachingOptimized
          OriginRequestPolicyId: 88a5eaf4-2fd4-4709-b370-b4c650ea3fcf # CORS-S3Origin
          ResponseHeadersPolicyId: 67f7725c-6f97-4210-82d7-5512b31e9d03 # SecurityHeadersPolicy
          ViewerProtocolPolicy: redirect-to-https
        CacheBehaviors:
          - PathPattern: "api/*"
            AllowedMethods:
            - GET
            - HEAD
            - OPTIONS
            - PUT
            - POST
            - DELETE
            - PATCH
            TargetOriginId: !Sub "${APIName}APIGTWOrigin"
            CachePolicyId: 4135ea2d-6df8-44a3-9df3-4b5a84be39ad # CachingDisabled
            OriginRequestPolicyId: b689b0a8-53d0-40ab-baf2-68738e2966ac # AllViewerExceptHostHeader
            ResponseHeadersPolicyId: 67f7725c-6f97-4210-82d7-5512b31e9d03 # SecurityHeadersPolicy
            ViewerProtocolPolicy: redirect-to-https
        PriceClass: PriceClass_All
        Logging:
          Bucket: !GetAtt LoggingBucket.RegionalDomainName
          Prefix: 'cloudfront-access-logs'
        ViewerCertificate:
          CloudFrontDefaultCertificate: true
          MinimumProtocolVersion: 'TLSv1.2_2021'

  # The Amazon CloudFront origin access control
  CloudFrontOriginAccessControl:
    Type: AWS::CloudFront::OriginAccessControl
    DependsOn:
      - S3Bucket
    Properties:
      OriginAccessControlConfig:
        Description: Default Origin Access Control
        Name: !Ref AWS::StackName
        OriginAccessControlOriginType: s3
        SigningBehavior: always
        SigningProtocol: sigv4

Outputs:
  AZA:
    Description: 'AZ of A'
    Value: !Select [0, !GetAZs '']
    Export:
      Name: !Sub '${AWS::StackName}-AZA'
  EC2SecurityGroupID:
    Description: 'The ID of the EC2 Security group'
    Value: !GetAtt EC2SecurityGroup.GroupId
    Export:
      Name: !Sub '${AWS::StackName}-EC2-ID'
