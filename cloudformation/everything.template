#!AWSTemplateFormat
AWSTemplateFormatVersion: 2010-09-09
Description: 'Deploys hasura ecs service for existing RDS and VPC'
Parameters:
  # You can/should edit "Default" values to ease up the deployment
  APIName:
    Description: 'The name of the ECS Service. Main Prefix., example: sfa-dev'
    Type: String
    Default: ''

  Environment:
    Description: "Env name, used in few places like sentry. Possible values: 'development', 'staging', 'production'"
    Type: String
    Default: 'development'

  DomainName:
    Type: String
    Description: 'The MAIN DNS name of an existing Amazon Route 53 hosted zone, example: sfaconstruction.net'
    Default: ''

  AppFullDomainName:
    Type: String
    Description: 'The full domain name where static app is hosted, must be a subdomain, example: app-dev.sfaconstruction.net'
    Default: ''
  ApiFullDomainName:
    Type: String
    Description: 'The full domain name where API is hosted, must be a subdomain, example: api-dev.sfaconstruction.net'
    Default: ''

  a0DomainName:
    Type: String
    Description: Domain name of a0 tenant. Something like dev-jnso8xn6b1daq18g.us.auth0.com
    Default: ''
  a0CustomDomainName:
    Type: String
    Description: Optional; Dedicated Domain name for FE auth on a0. Something like dev-jnso8xn6b1daq18g.us.auth0.com
    Default: ''
  a0ApiIdentifier:
    Type: String
    Description: a0 API identifier of Frontend app, e.g. https://api-staging.sfaconstruction.net
    Default: ''

  APPCertificateARN:
    Description: Arn of the main APP.<domain> SSL certificate, must be in east-1 region
    Type: String
    Default: ''
    AllowedPattern: "arn:aws:acm:us-east-1:.*"
  APICertificateARN:
    Description: 'Arn of the main API.<domain> SSL certificate, must be in the deployment region'
    Type: String
    Default: ''
    AllowedPattern: "arn:aws:acm:.*"

  DBEndpoint:
    Description: 'The endpoint for PostgreSQL'
    Type: String
    Default: ''

  DBUsername:
    Description: 'The DB username that will be used for the Django user in PostgreSQL'
    Type: String
    Default: 'sfa_dev'

  DBName:
    Description: 'The name of the PostgreSQL database'
    Type: String
    Default: 'sfa_dev'

  HasuraDBUsername:
    Description: 'The DB username that will be used for Hasura in PostgreSQL'
    Type: String
    Default: 'sfa_dev_hasura'

  RedisHost:
    Description: 'The hostname of the Redis database'
    Type: String
    Default: ''
    AllowedPattern: "[^:]*"

  RedisPort:
    Description: 'The port of the Redis database'
    Type: String
    Default: '6379'

  HasuraDockerImage:
    Description: 'Name and tag of the Hasura Docker Image, example for dev: hasura/graphql-engine:v2.24.1, example for staging: 123.dkr.ecr.us-west-1.amazonaws.com/sfa/hasura-staging:latest'
    Type: String
    Default: 'hasura/graphql-engine:v2.24.1'

  DjangoDockerImage:
    Description: 'Name and tag of the Django Docker Image, example: 232267884965.dkr.ecr.us-west-1.amazonaws.com/sfa/django-app-staging:latest'
    Type: String
    Default: ''

  StorageDockerImage:
    Description: 'Leave as default; Name and tag of the Storage API Docker Image'
    Type: String
    Default: 'nhost/hasura-storage:0.3.6'

  HasuraHealthCheckPath:
    Description: 'Leave as default; The Health check path. Hasura exposes /healthz as a health check path. Used on the LoadBalancing Target group.'
    Type: String
    Default: /healthz

  HasuraAWSSecretName:
    Description: 'The NAME of a secret in AWS Secret manager containing Hasura related secrets'
    Type: String
    Default: 'sfa-hasura-secret'

  HasuraAWSSecretArn:
    Description: 'The ARN of a secret in AWS Secret manager containing Hasura related secrets, can be shared with Django secret'
    Type: String
    Default: 'arn:aws:secretsmanager:'
    AllowedPattern: 'arn:aws:secretsmanager:.*'

  DjangoAWSSecretArn:
    Description: 'The ARN of a secret in AWS Secret manager containing Django related secrets, can be shared with Hasura secret'
    Type: String
    Default: 'arn:aws:secretsmanager:'
    AllowedPattern: 'arn:aws:secretsmanager:.*'

  HasuraGraphqlEnableConsole:
    Description: 'Enable the Hasura Console (served by the server on / and /console), disable on production'
    Type: String
    Default: 'true'

  HasuraGraphqlDevMode:
    Description: 'Sets dev mode for GraphQL requests, i.e. in case of errors, includes an internal key in the errors extensions of the response, disable on production/staging'
    Type: String
    Default: 'true'

  HasuraGraphqlEnableAPIs:
    Description: 'List of APIs to be enabled on a Hasura GraphQL Engine instance; use "graphql" on Prod'
    Type: String
    Default: 'metadata, graphql, pgdump, config'

  OneSignalAppId:
    Description: 'Optional; App ID for OneSignal integration'
    Type: String
    Default: ''

  OneSignalTwilioFromNumber:
    Description: 'Optional; Twilio phone number used for outgoing sms, must be linked to onesignal account'
    Type: String
    Default: ''

  VpcId:
    Type: AWS::EC2::VPC::Id
    Description: VPC that has access to the postgres db
    Default: 'vpc-xxx'
  VpcCIDR:
    Type: String
    Description: "VPC's CIDR"
    Default: '10.20.0.0/16'

  VpcPublicSubnetA:
    Type: AWS::EC2::Subnet::Id
    Description: List of 2 public SubnetIds for the given VPC.
    Default: 'subnet-xxx'
  VpcPublicSubnetB:
    Type: AWS::EC2::Subnet::Id
    Description: 'B'
    Default: 'subnet-yyy'

  VpcPrivateSubnetA:
    Type: AWS::EC2::Subnet::Id
    Description: List of 2 private SubnetIds for the given VPC.
    Default: 'subnet-aaa'
  VpcPrivateSubnetB:
    Type: AWS::EC2::Subnet::Id
    Description: 'B'
    Default: 'subnet-bbb'

  RDSSecurityGroupID:
    Type: AWS::EC2::SecurityGroup::Id
    Description: 'ID of RDS security group that will be modified to allow access on 5432 port'
    Default: 'sg-xxx'
  RedisSecurityGroupID:
    Type: AWS::EC2::SecurityGroup::Id
    Description: 'ID of Redis security group that will be modified to allow access on 6379 port'
    Default: 'sg-yyy'

  PlaidEnv:
    Type: String
    Description: 'Plaid env, Sandbox,Development,Production'
    Default: 'Sandbox'

  TwilioVerifyServiceId:
    Type: String
    Description: 'Optional; TWILIO_VERIFY_SID value; Get this value from Twilio after creating a "verify service", used to verify phone numbers'
    Default: ''

  TwilioFromNumber:
    Type: String
    Description: 'Optional; Phone Number used for direct outgoing SMS, not related to verification'
    Default: ''

  CometChatApiUrl:
    Type: String
    Description: 'COMET_CHAT_API_URL value'
    Default: 'https://254877885795d07a.api-us.cometchat.io'

  signWellAPIAppId:
    Type: String
    Description: 'Optional; SignWell API App ID. Signwell webhook key relates to App ID. If value is not specified use default WebHook key'
    Default: ''

  treasuryPrimeApiEndpoint:
    Type: String
    Description: 'Treasury Prime API URL; https://api.treasuryprime.com, https://api.sandbox.treasuryprime.com (SandBox)'
    Default: ''


Mappings:
  ALL:
    Ports:
      HasuraContainerPort: 8080
      DjangoContainerPort: 8080
      StorageContainerPort: 8000

Resources:
  ECSServiceNamespace:
    Type: AWS::ServiceDiscovery::PrivateDnsNamespace
    Properties:
      Description: Internal DSN namespace
      Name: !Ref APIName
      Properties:
        DnsProperties:
          SOA:
            TTL: 60
      Vpc: !Ref 'VpcId'

  HasuraSDService:
    Type: AWS::ServiceDiscovery::Service
    Properties:
      Name: hasura-api
      Description: Hasura internal DNS
      DnsConfig:
        DnsRecords:
          - Type: A
            TTL: 60
          - Type: AAAA
            TTL: 60
        RoutingPolicy: WEIGHTED
        # HC should not be needed as it is performed by the ALB already
      #      HealthCheckConfig:
      #        FailureThreshold: 3
      #        ResourcePath: /healthz
      #        Type: HTTP
      NamespaceId: !Ref ECSServiceNamespace

  DjangoSDService:
    Type: AWS::ServiceDiscovery::Service
    Properties:
      Name: django-api
      Description: Django internal DNS
      DnsConfig:
        DnsRecords:
          - Type: A
            TTL: 60
          - Type: AAAA
            TTL: 60
        RoutingPolicy: WEIGHTED
      #      HealthCheckConfig:
      #        FailureThreshold: 3
      #        ResourcePath: /healthz
      #        Type: HTTP
      NamespaceId: !Ref ECSServiceNamespace

  StorageSDService:
    Type: AWS::ServiceDiscovery::Service
    Properties:
      Name: storage-api
      Description: Storage internal DNS
      DnsConfig:
        DnsRecords:
          - Type: A
            TTL: 60
          - Type: AAAA
            TTL: 60
        RoutingPolicy: WEIGHTED
      #      HealthCheckConfig:
      #        FailureThreshold: 3
      #        ResourcePath: /healthz
      #        Type: HTTP
      NamespaceId: !Ref ECSServiceNamespace

  LoadBalancerSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupName: !Sub '${APIName}-ELB-SecurityGroup'
      GroupDescription: !Sub 'Security group to control external access to the load balancer. ${APIName}'
      VpcId: !Ref 'VpcId'
      SecurityGroupIngress:
        - IpProtocol: 'tcp'
          FromPort: 443
          ToPort: 443
          CidrIp: '0.0.0.0/0'
        - IpProtocol: 'tcp'
          FromPort: 80
          ToPort: 80
          CidrIp: '0.0.0.0/0'
      Tags:
        - Key: 'Name'
          Value: !Sub '${APIName}-ELB-SecurityGroup'

  #After traffic comes in through a load balancer it goes to an EC2 instance. The EC2 instance should allow traffic from the load balancer over both port 80 and 8080 which are two common ports.
  EC2SecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupName: !Sub '${APIName}-EC2-SecurityGroup'
      GroupDescription: !Sub 'Security group to control access to an EC2 instances inside the ${APIName} stack VPC'
      VpcId: !Ref 'VpcId'
      SecurityGroupIngress:
        - IpProtocol: 'tcp'
          SourceSecurityGroupId: !Ref LoadBalancerSecurityGroup
          Description: LB access to hasura
          FromPort: 8080
          ToPort: 8080
        - IpProtocol: 'tcp'
          SourceSecurityGroupId: !Ref LoadBalancerSecurityGroup
          Description: LB access to hasura-storage
          FromPort: 8000
          ToPort: 8000
      Tags:
        - Key: 'Name'
          Value: !Sub '${APIName}-EC2-SecurityGroup'

  EC2SecurityGroupHasuraStorageSGIngress:
    Type: AWS::EC2::SecurityGroupIngress
    DependsOn: EC2SecurityGroup
    Properties:
      GroupId:
        Ref: EC2SecurityGroup
      IpProtocol: tcp
      FromPort: '8000'
      ToPort: '8000'
      Description: Allow access to hasura-storage from self
      SourceSecurityGroupId:
        Ref: EC2SecurityGroup

  EC2SecurityGroupHasuraSGIngress:
    Type: AWS::EC2::SecurityGroupIngress
    DependsOn: EC2SecurityGroup
    Properties:
      GroupId:
        Ref: EC2SecurityGroup
      IpProtocol: tcp
      FromPort: '8080'
      ToPort: '8080'
      Description: Allow access to Hasura from self
      SourceSecurityGroupId:
        Ref: EC2SecurityGroup

  # A role needed by ECS
  ECSExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Join [ '-', [ !Ref APIName, ExecutionRole ] ]
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com
            Action: 'sts:AssumeRole'
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy'
      Policies:
        - PolicyName: AllowSMAccess
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Sid: SMAccess
                Effect: Allow
                Action:
                  # - "ssm:GetParameters"
                  - "secretsmanager:GetSecretValue"
                  # - "kms:Decrypt"  # required if custom kms is used
                Resource:
                  # - "arn:aws:ssm:region:aws_account_id:parameter/parameter_name"
                  - !Ref HasuraAWSSecretArn
                  - !Ref DjangoAWSSecretArn
                  # - "arn:aws:kms:region:aws_account_id:key/key_id"
  # A role for the containers
  ECSTaskRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Join [ '-', [ !Ref APIName, TaskRole ] ]
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com
            Action: 'sts:AssumeRole'

  AppLoadBalancer:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      LoadBalancerAttributes:
        - Key: idle_timeout.timeout_seconds  # not applicable to NLB
          Value: 360
      Name: !Join [ '-', [ !Ref APIName, ALB ] ]
      Scheme: internet-facing
      Type: application
      SecurityGroups:
        - !Ref 'LoadBalancerSecurityGroup'
      Subnets:
        - !Ref 'VpcPublicSubnetA'
        - !Ref 'VpcPublicSubnetB'

  ECSCluster:
    Type: AWS::ECS::Cluster
    Properties:
      ClusterName: !Join [ '-', [ !Ref APIName, Cluster ] ]
      ServiceConnectDefaults:
        Namespace: !GetAtt ECSServiceNamespace.Arn

  HasuraLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Join [ '', [ /ecs/, !Ref APIName, HasuraTaskDefinition ] ]

  #https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ecs-taskdefinition.html
  HasuraTaskDefinition:
    Type: AWS::ECS::TaskDefinition
    # Makes sure the log group is created before it is used.
    DependsOn: HasuraLogGroup
    Properties:
      # Name of the task definition. Subsequent versions of the task definition are grouped together under this name.
      Family: !Join [ '-', [ !Ref APIName, HasuraTaskDefinition ] ]
      # awsvpc is required for Fargate
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - FARGATE
      # 256 (.25 vCPU) - Available memory values: 0.5GB, 1GB, 2GB
      # 512 (.5 vCPU) - Available memory values: 1GB, 2GB, 3GB, 4GB
      # 1024 (1 vCPU) - Available memory values: 2GB, 3GB, 4GB, 5GB, 6GB, 7GB, 8GB
      # 2048 (2 vCPU) - Available memory values: Between 4GB and 16GB in 1GB increments
      # 4096 (4 vCPU) - Available memory values: Between 8GB and 30GB in 1GB increments
      Cpu: 1024
      # 0.5GB, 1GB, 2GB - Available cpu values: 256 (.25 vCPU)
      # 1GB, 2GB, 3GB, 4GB - Available cpu values: 512 (.5 vCPU)
      # 2GB, 3GB, 4GB, 5GB, 6GB, 7GB, 8GB - Available cpu values: 1024 (1 vCPU)
      # Between 4GB and 16GB in 1GB increments - Available cpu values: 2048 (2 vCPU)
      # Between 8GB and 30GB in 1GB increments - Available cpu values: 4096 (4 vCPU)
      Memory: 2GB
      # A role needed by ECS.
      # "The ARN of the task execution role that containers in this task can assume. All containers in this task are granted the permissions that are specified in this role."
      # "There is an optional task execution IAM role that you can specify with Fargate to allow your Fargate tasks to make API calls to Amazon ECR."
      ExecutionRoleArn: !Ref ECSExecutionRole
      # "The Amazon Resource Name (ARN) of an AWS Identity and Access Management (IAM) role that grants containers in the task permission to call AWS APIs on your behalf."
      TaskRoleArn: !Ref ECSTaskRole
      ContainerDefinitions:
        - Name: !Join [ '-', [ !Ref APIName, hasura-container ] ]
          Image: !Ref HasuraDockerImage
          PortMappings:
            - ContainerPort: !FindInMap [ ALL,  Ports,  HasuraContainerPort ]
              Name: hasuraapp
              AppProtocol: http
          # Send logs to CloudWatch Logs
          Environment:
            - Name: 'HASURA_GRAPHQL_DATABASE_URL'
              #Make the PostgreSQL connection string from the parameters we have.
              Value:
                !Join [
                  '',
                  [
                    'postgres://',
                    !Ref 'HasuraDBUsername',
                    ':',
                    # alternative is to put whole string into the secret manager...
                    !Sub '{{resolve:secretsmanager:${HasuraAWSSecretName}:SecretString:HASURA_DB_PASSWORD}}',
                    '@',
                    !Ref 'DBEndpoint',
                    ':5432/',
                    !Ref 'DBName',
                  ],
                ]
            - Name: 'HASURA_GRAPHQL_ENABLE_CONSOLE'
              Value: !Ref HasuraGraphqlEnableConsole
            - Name: 'HASURA_GRAPHQL_ENABLE_TELEMETRY'
              Value: 'false'
            - Name: 'HASURA_GRAPHQL_ENABLED_LOG_TYPES'
              Value: 'startup, http-log, webhook-log, websocket-log, query-log'
            - Name: 'HASURA_GRAPHQL_DEV_MODE'
              Value: !Ref HasuraGraphqlDevMode
            - Name: 'HASURA_GRAPHQL_UNAUTHORIZED_ROLE'
              Value: 'guest'
            - Name: 'HASURA_GRAPHQL_ENABLED_APIS'
              Value: !Ref HasuraGraphqlEnableAPIs
            - Name: 'HASURA_GRAPHQL_METADATA_DEFAULTS'
              Value: "{\"backend_configs\":{\"dataconnector\":{\"athena\":{\"uri\":\"http://data-connector-agent:8081/api/v1/athena\"},\"mariadb\":{\"uri\":\"http://data-connector-agent:8081/api/v1/mariadb\"},\"mysql8\":{\"uri\":\"http://data-connector-agent:8081/api/v1/mysql\"},\"oracle\":{\"uri\":\"http://data-connector-agent:8081/api/v1/oracle\"},\"snowflake\":{\"uri\":\"http://data-connector-agent:8081/api/v1/snowflake\"}}}}"
          Secrets:
            - Name: 'HASURA_GRAPHQL_ADMIN_SECRET'
              ValueFrom: !Sub '${HasuraAWSSecretArn}:HASURA_GRAPHQL_ADMIN_SECRET::'
            - Name: 'HASURA_GRAPHQL_JWT_SECRET'
              ValueFrom: !Sub '${HasuraAWSSecretArn}:HASURA_GRAPHQL_JWT_SECRET::'
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-region: !Ref AWS::Region
              awslogs-group: !Ref HasuraLogGroup
              awslogs-stream-prefix: ecs

  HasuraService:
    Type: AWS::ECS::Service
    # This dependency is needed so that the load balancer is setup correctly in time
    DependsOn:
      - AppLoadBalancer
      - ALBListenerHTTPS
      - HasuraTargetGroup
    Properties:
      ServiceName: !Join [ '-', [ !Ref APIName, hasura ] ]
      Cluster: !Ref ECSCluster
      TaskDefinition: !Ref HasuraTaskDefinition
      DeploymentConfiguration:
        MinimumHealthyPercent: 100
        MaximumPercent: 200
        DeploymentCircuitBreaker:
          Enable: false
          Rollback: false
      DesiredCount: 1
      # This may need to be adjusted if the container takes a while to start up
      HealthCheckGracePeriodSeconds: 120
      LaunchType: FARGATE
      NetworkConfiguration:
        AwsvpcConfiguration:
          # change to DISABLED if you're using private subnets that have access to a NAT gateway
          AssignPublicIp: DISABLED
          Subnets:
            - !Ref 'VpcPrivateSubnetA'
            - !Ref 'VpcPrivateSubnetB'
          SecurityGroups:
            - !Ref 'EC2SecurityGroup'
      ServiceConnectConfiguration:
        Enabled: false
      ServiceRegistries:
        - RegistryArn: !GetAtt HasuraSDService.Arn
          ContainerName: !Join [ '-', [ !Ref APIName, hasura-container ] ]
          # ContainerPort: !Ref HasuraContainerPort  # somehow port causes error
      EnableECSManagedTags: true
      DeploymentController:
        Type: ECS
      SchedulingStrategy: REPLICA
      LoadBalancers:
        - ContainerName: !Join [ '-', [ !Ref APIName, hasura-container ] ]
          ContainerPort: !FindInMap [ ALL,  Ports,  HasuraContainerPort ]
          TargetGroupArn: !Ref HasuraTargetGroup

  HasuraTargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    DependsOn: AppLoadBalancer
    Properties:
      Name: !Join [ '-', [ !Ref APIName, tg ] ]
      Protocol: HTTP
      Port: !FindInMap [ ALL,  Ports,  HasuraContainerPort ]
      HealthCheckIntervalSeconds: 30
      # will look for a 200 status code by default unless specified otherwise
      HealthCheckProtocol: HTTP
      HealthCheckPath: !Ref HasuraHealthCheckPath
      HealthCheckTimeoutSeconds: 5
      UnhealthyThresholdCount: 2
      HealthyThresholdCount: 2
      TargetGroupAttributes:
        - Key: deregistration_delay.timeout_seconds
          Value: 60 # default is 300
      TargetType: ip
      VpcId: !Ref VpcId

  ALBHTTPListenerRedirector:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      DefaultActions:
        - Type: "redirect"
          RedirectConfig:
            Protocol: "HTTPS"
            Port: 443
            Host: "#{host}"
            Path: "/#{path}"
            Query: "#{query}"
            StatusCode: "HTTP_301"
      LoadBalancerArn: !Ref AppLoadBalancer
      Port: 80
      Protocol: "HTTP"

  ALBListenerHTTPS:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      DefaultActions:
        - TargetGroupArn: !Ref HasuraTargetGroup
          Type: forward
      Certificates:
        - CertificateArn: !Ref APICertificateARN
      LoadBalancerArn: !Ref AppLoadBalancer
      Port: 443
      Protocol: HTTPS

  DjangoListenerRuleHTTPS:
    Type: AWS::ElasticLoadBalancingV2::ListenerRule
    Properties:
      Actions:
        - Type: forward
          TargetGroupArn: !Ref DjangoTargetGroup
      Conditions:
        - Field: path-pattern
          Values:
            - "/da/*"
      ListenerArn: !Ref ALBListenerHTTPS
      Priority: 1

  DjangoLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Join [ '', [ /ecs/, !Ref APIName, DjangoTaskDefinition ] ]

  DjangoAPITaskDefinition:
    Type: AWS::ECS::TaskDefinition
    # Makes sure the log group is created before it is used.
    DependsOn: DjangoLogGroup
    Properties:
      # Name of the task definition. Subsequent versions of the task definition are grouped together under this name.
      Family: !Join [ '-', [ !Ref APIName, DjangoTaskDefinition ] ]
      # awsvpc is required for Fargate
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - FARGATE
      # 256 (.25 vCPU) - Available memory values: 0.5GB, 1GB, 2GB
      # 512 (.5 vCPU) - Available memory values: 1GB, 2GB, 3GB, 4GB
      # 1024 (1 vCPU) - Available memory values: 2GB, 3GB, 4GB, 5GB, 6GB, 7GB, 8GB
      # 2048 (2 vCPU) - Available memory values: Between 4GB and 16GB in 1GB increments
      # 4096 (4 vCPU) - Available memory values: Between 8GB and 30GB in 1GB increments
      Cpu: 1024
      # 0.5GB, 1GB, 2GB - Available cpu values: 256 (.25 vCPU)
      # 1GB, 2GB, 3GB, 4GB - Available cpu values: 512 (.5 vCPU)
      # 2GB, 3GB, 4GB, 5GB, 6GB, 7GB, 8GB - Available cpu values: 1024 (1 vCPU)
      # Between 4GB and 16GB in 1GB increments - Available cpu values: 2048 (2 vCPU)
      # Between 8GB and 30GB in 1GB increments - Available cpu values: 4096 (4 vCPU)
      Memory: 2GB
      # A role needed by ECS.
      # "The ARN of the task execution role that containers in this task can assume. All containers in this task are granted the permissions that are specified in this role."
      # "There is an optional task execution IAM role that you can specify with Fargate to allow your Fargate tasks to make API calls to Amazon ECR."
      ExecutionRoleArn: !Ref ECSExecutionRole
      # "The Amazon Resource Name (ARN) of an AWS Identity and Access Management (IAM) role that grants containers in the task permission to call AWS APIs on your behalf."
      TaskRoleArn: !Ref ECSTaskRole
      ContainerDefinitions:
        - Name: !Join [ '-', [ !Ref APIName, djangoApi-container ] ]
          Image: !Ref DjangoDockerImage
          PortMappings:
            - ContainerPort: !FindInMap [ ALL,  Ports,  DjangoContainerPort ]
              Name: djangoapp
              AppProtocol: http
          Environment:
            - Name: 'ENVIRONMENT'
              Value: !Ref Environment
            - Name: 'DATA_DB_NAME'
              Value: !Ref DBName
            - Name: 'DATA_DB_USER'
              Value: !Ref DBUsername
            - Name: 'DATA_DB_HOST'
              Value: !Ref DBEndpoint
            - Name: 'DATA_DB_PORT'
              Value: '5432'
            - Name: 'DATA_DB_CONN_MAX_AGE'
              Value: "0"
            - Name: 'DRAMATIQ_REDIS_HOST'
              Value: !Ref RedisHost
            - Name: 'DRAMATIQ_REDIS_PORT'
              Value: !Ref RedisPort
            - Name: 'DRAMATIQ_NAMESPACE'
              Value: !Ref APIName
            - Name: 'AUTH0_DOMAIN'
              Value: !Ref a0DomainName
            - Name: 'AUTH0_CUSTOM_DOMAIN'
              Value: !Ref a0CustomDomainName
            - Name: 'AUTH0_API_IDENTIFIER'
              Value: !Ref a0ApiIdentifier
            - Name: 'API_DOMAIN_NAME'
              Value: !Ref ApiFullDomainName
            - Name: 'APP_DOMAIN_NAME'
              Value: !Ref AppFullDomainName
            - Name: 'PLAID_ENV'
              Value: !Ref PlaidEnv
            - Name: 'ONESIGNAL_APP_ID'
              Value: !Ref OneSignalAppId
            - Name: 'ONESIGNAL_TWILIO_FROM_NUMBER'
              Value: !Ref OneSignalTwilioFromNumber
            - Name: 'TWILIO_VERIFY_SID'
              Value: !Ref TwilioVerifyServiceId
            - Name: 'SENTRY_ENV'
              Value: !Ref Environment
            - Name: 'TWILIO_FROM_NUMBER'
              Value: !Ref TwilioFromNumber
            - Name: 'COMET_CHAT_API_URL'
              Value: !Ref CometChatApiUrl
            - Name: 'SIGNWELL_API_APP_ID'
              Value: !Ref signWellAPIAppId
            - Name: 'TREASURY_PRIME_API_ENDPOINT'
              Value: !Ref treasuryPrimeApiEndpoint
          Secrets:
            - Name: 'DATA_DB_PASSWORD'
              ValueFrom: !Sub '${DjangoAWSSecretArn}:DJANGO_DATA_DB_PASSWORD::'
            - Name: 'AUTH0_MANAGEMENT_CLIENT_SECRET'
              ValueFrom: !Sub '${DjangoAWSSecretArn}:AUTH0_MANAGEMENT_CLIENT_SECRET::'
            - Name: 'AUTH0_MANAGEMENT_CLIENT_ID'
              ValueFrom: !Sub '${DjangoAWSSecretArn}:AUTH0_MANAGEMENT_CLIENT_ID::'
            - Name: 'PLAID_CLIENT_ID'
              ValueFrom: !Sub '${DjangoAWSSecretArn}:PLAID_CLIENT_ID::'
            - Name: 'PLAID_SECRET'
              ValueFrom: !Sub '${DjangoAWSSecretArn}:PLAID_SECRET::'
            - Name: 'ONESIGNAL_API_KEY'
              ValueFrom: !Sub '${DjangoAWSSecretArn}:ONESIGNAL_API_KEY::'
            - Name: 'TWILIO_AUTH_TOKEN'
              ValueFrom: !Sub '${DjangoAWSSecretArn}:TWILIO_AUTH_TOKEN::'
            - Name: 'TWILIO_ACCOUNT_SID'
              ValueFrom: !Sub '${DjangoAWSSecretArn}:TWILIO_ACCOUNT_SID::'
            - Name: 'SENDGRID_API_KEY'
              ValueFrom: !Sub '${DjangoAWSSecretArn}:SENDGRID_API_KEY::'
            - Name: 'SENTRY_DSN'
              ValueFrom: !Sub '${DjangoAWSSecretArn}:SENTRY_DSN::'
            - Name: 'DJANGO_SECRET_KEY'
              ValueFrom: !Sub '${DjangoAWSSecretArn}:DJANGO_SECRET_KEY::'
            - Name: 'COMET_CHAT_REST_KEY'
              ValueFrom: !Sub '${DjangoAWSSecretArn}:COMET_CHAT_REST_KEY::'
            - Name: 'STRIPE_API_KEY'
              ValueFrom: !Sub '${DjangoAWSSecretArn}:STRIPE_API_KEY::'
            - Name: 'STRIPE_PUBLISHABLE_KEY'
              ValueFrom: !Sub '${DjangoAWSSecretArn}:STRIPE_PUBLISHABLE_KEY::'
            - Name: 'SIGNWELL_API_KEY'
              ValueFrom: !Sub '${DjangoAWSSecretArn}:SIGNWELL_API_KEY::'
            - Name: 'SIGNWELL_WEBHOOK_KEY'
              ValueFrom: !Sub '${DjangoAWSSecretArn}:SIGNWELL_WEBHOOK_KEY::'
            - Name: 'TREASURY_PRIME_API_KEY_ID'
              ValueFrom: !Sub '${DjangoAWSSecretArn}:TREASURY_PRIME_API_KEY_ID::'
            - Name: 'TREASURY_PRIME_API_SECRET_KEY'
              ValueFrom: !Sub '${DjangoAWSSecretArn}:TREASURY_PRIME_API_SECRET_KEY::'
            - Name: 'TREASURY_PRIME_WEBHOOK_USERNAME'
              ValueFrom: !Sub '${DjangoAWSSecretArn}:TREASURY_PRIME_WEBHOOK_USERNAME::'
            - Name: 'TREASURY_PRIME_WEBHOOK_PASSWORD'
              ValueFrom: !Sub '${DjangoAWSSecretArn}:TREASURY_PRIME_WEBHOOK_PASSWORD::'
            - Name: 'HASURA_GRAPHQL_ADMIN_SECRET'
              ValueFrom: !Sub '${HasuraAWSSecretArn}:HASURA_GRAPHQL_ADMIN_SECRET::'

          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-region: !Ref AWS::Region
              awslogs-group: !Ref DjangoLogGroup
              awslogs-stream-prefix: ecs

  DjangoDMTQTaskDefinition:
    Type: AWS::ECS::TaskDefinition
    # Makes sure the log group is created before it is used.
    DependsOn: DjangoLogGroup
    Properties:
      # Name of the task definition. Subsequent versions of the task definition are grouped together under this name.
      Family: !Join [ '-', [ !Ref APIName, DjangoDMTQTaskDefinition ] ]
      # awsvpc is required for Fargate
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - FARGATE
      # 256 (.25 vCPU) - Available memory values: 0.5GB, 1GB, 2GB
      # 512 (.5 vCPU) - Available memory values: 1GB, 2GB, 3GB, 4GB
      # 1024 (1 vCPU) - Available memory values: 2GB, 3GB, 4GB, 5GB, 6GB, 7GB, 8GB
      # 2048 (2 vCPU) - Available memory values: Between 4GB and 16GB in 1GB increments
      # 4096 (4 vCPU) - Available memory values: Between 8GB and 30GB in 1GB increments
      Cpu: 1024
      # 0.5GB, 1GB, 2GB - Available cpu values: 256 (.25 vCPU)
      # 1GB, 2GB, 3GB, 4GB - Available cpu values: 512 (.5 vCPU)
      # 2GB, 3GB, 4GB, 5GB, 6GB, 7GB, 8GB - Available cpu values: 1024 (1 vCPU)
      # Between 4GB and 16GB in 1GB increments - Available cpu values: 2048 (2 vCPU)
      # Between 8GB and 30GB in 1GB increments - Available cpu values: 4096 (4 vCPU)
      Memory: 2GB
      # A role needed by ECS.
      # "The ARN of the task execution role that containers in this task can assume. All containers in this task are granted the permissions that are specified in this role."
      # "There is an optional task execution IAM role that you can specify with Fargate to allow your Fargate tasks to make API calls to Amazon ECR."
      ExecutionRoleArn: !Ref ECSExecutionRole
      # "The Amazon Resource Name (ARN) of an AWS Identity and Access Management (IAM) role that grants containers in the task permission to call AWS APIs on your behalf."
      TaskRoleArn: !Ref ECSTaskRole
      ContainerDefinitions:
        - Name: !Join [ '-', [ !Ref APIName, djangoDMTQ-container ] ]
          Image: !Ref DjangoDockerImage
          EntryPoint:
            - "sh"
            - "-c"
            - "python manage.py rundramatiq"
          WorkingDirectory: "/app"
          Environment:
            - Name: 'ENVIRONMENT'
              Value: !Ref Environment
            - Name: 'DATA_DB_NAME'
              Value: !Ref DBName
            - Name: 'DATA_DB_USER'
              Value: !Ref DBUsername
            - Name: 'DATA_DB_HOST'
              Value: !Ref DBEndpoint
            - Name: 'DATA_DB_PORT'
              Value: '5432'
            - Name: 'DATA_DB_CONN_MAX_AGE'
              Value: "0"
            - Name: 'DRAMATIQ_REDIS_HOST'
              Value: !Ref RedisHost
            - Name: 'DRAMATIQ_REDIS_PORT'
              Value: !Ref RedisPort
            - Name: 'DRAMATIQ_NAMESPACE'
              Value: !Ref APIName
            - Name: 'AUTH0_DOMAIN'
              Value: !Ref a0DomainName
            - Name: 'AUTH0_CUSTOM_DOMAIN'
              Value: !Ref a0CustomDomainName
            - Name: 'AUTH0_API_IDENTIFIER'
              Value: !Ref a0ApiIdentifier
            - Name: 'API_DOMAIN_NAME'
              Value: !Ref ApiFullDomainName
            - Name: 'APP_DOMAIN_NAME'
              Value: !Ref AppFullDomainName
            - Name: 'PLAID_ENV'
              Value: !Ref PlaidEnv
            - Name: 'ONESIGNAL_APP_ID'
              Value: !Ref OneSignalAppId
            - Name: 'ONESIGNAL_TWILIO_FROM_NUMBER'
              Value: !Ref OneSignalTwilioFromNumber
            - Name: 'TWILIO_VERIFY_SID'
              Value: !Ref TwilioVerifyServiceId
            - Name: 'SENTRY_ENV'
              Value: !Ref Environment
            - Name: 'TWILIO_FROM_NUMBER'
              Value: !Ref TwilioFromNumber
            - Name: 'COMET_CHAT_API_URL'
              Value: !Ref CometChatApiUrl
            - Name: 'SIGNWELL_API_APP_ID'
              Value: !Ref signWellAPIAppId
            - Name: 'TREASURY_PRIME_API_ENDPOINT'
              Value: !Ref treasuryPrimeApiEndpoint
          Secrets:
            - Name: 'DATA_DB_PASSWORD'
              ValueFrom: !Sub '${DjangoAWSSecretArn}:DJANGO_DATA_DB_PASSWORD::'
            - Name: 'AUTH0_MANAGEMENT_CLIENT_SECRET'
              ValueFrom: !Sub '${DjangoAWSSecretArn}:AUTH0_MANAGEMENT_CLIENT_SECRET::'
            - Name: 'AUTH0_MANAGEMENT_CLIENT_ID'
              ValueFrom: !Sub '${DjangoAWSSecretArn}:AUTH0_MANAGEMENT_CLIENT_ID::'
            - Name: 'PLAID_CLIENT_ID'
              ValueFrom: !Sub '${DjangoAWSSecretArn}:PLAID_CLIENT_ID::'
            - Name: 'PLAID_SECRET'
              ValueFrom: !Sub '${DjangoAWSSecretArn}:PLAID_SECRET::'
            - Name: 'ONESIGNAL_API_KEY'
              ValueFrom: !Sub '${DjangoAWSSecretArn}:ONESIGNAL_API_KEY::'
            - Name: 'TWILIO_AUTH_TOKEN'
              ValueFrom: !Sub '${DjangoAWSSecretArn}:TWILIO_AUTH_TOKEN::'
            - Name: 'TWILIO_ACCOUNT_SID'
              ValueFrom: !Sub '${DjangoAWSSecretArn}:TWILIO_ACCOUNT_SID::'
            - Name: 'SENDGRID_API_KEY'
              ValueFrom: !Sub '${DjangoAWSSecretArn}:SENDGRID_API_KEY::'
            - Name: 'SENTRY_DSN'
              ValueFrom: !Sub '${DjangoAWSSecretArn}:SENTRY_DSN::'
            - Name: 'DJANGO_SECRET_KEY'
              ValueFrom: !Sub '${DjangoAWSSecretArn}:DJANGO_SECRET_KEY::'
            - Name: 'COMET_CHAT_REST_KEY'
              ValueFrom: !Sub '${DjangoAWSSecretArn}:COMET_CHAT_REST_KEY::'
            - Name: 'STRIPE_API_KEY'
              ValueFrom: !Sub '${DjangoAWSSecretArn}:STRIPE_API_KEY::'
            - Name: 'STRIPE_PUBLISHABLE_KEY'
              ValueFrom: !Sub '${DjangoAWSSecretArn}:STRIPE_PUBLISHABLE_KEY::'
            - Name: 'SIGNWELL_API_KEY'
              ValueFrom: !Sub '${DjangoAWSSecretArn}:SIGNWELL_API_KEY::'
            - Name: 'SIGNWELL_WEBHOOK_KEY'
              ValueFrom: !Sub '${DjangoAWSSecretArn}:SIGNWELL_WEBHOOK_KEY::'
            - Name: 'TREASURY_PRIME_API_KEY_ID'
              ValueFrom: !Sub '${DjangoAWSSecretArn}:TREASURY_PRIME_API_KEY_ID::'
            - Name: 'TREASURY_PRIME_API_SECRET_KEY'
              ValueFrom: !Sub '${DjangoAWSSecretArn}:TREASURY_PRIME_API_SECRET_KEY::'
            - Name: 'TREASURY_PRIME_WEBHOOK_USERNAME'
              ValueFrom: !Sub '${DjangoAWSSecretArn}:TREASURY_PRIME_WEBHOOK_USERNAME::'
            - Name: 'TREASURY_PRIME_WEBHOOK_PASSWORD'
              ValueFrom: !Sub '${DjangoAWSSecretArn}:TREASURY_PRIME_WEBHOOK_PASSWORD::'
            - Name: 'HASURA_GRAPHQL_ADMIN_SECRET'
              ValueFrom: !Sub '${HasuraAWSSecretArn}:HASURA_GRAPHQL_ADMIN_SECRET::'

          # Send logs to CloudWatch Logs
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-region: !Ref AWS::Region
              awslogs-group: !Ref DjangoLogGroup
              awslogs-stream-prefix: ecs

  DjangoCronTaskDefinition:
    Type: AWS::ECS::TaskDefinition
    # Makes sure the log group is created before it is used.
    DependsOn: DjangoLogGroup
    Properties:
      # Name of the task definition. Subsequent versions of the task definition are grouped together under this name.
      Family: !Join [ '-', [ !Ref APIName, DjangoCronTaskDefinition ] ]
      # awsvpc is required for Fargate
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - FARGATE
      # 256 (.25 vCPU) - Available memory values: 0.5GB, 1GB, 2GB
      # 512 (.5 vCPU) - Available memory values: 1GB, 2GB, 3GB, 4GB
      # 1024 (1 vCPU) - Available memory values: 2GB, 3GB, 4GB, 5GB, 6GB, 7GB, 8GB
      # 2048 (2 vCPU) - Available memory values: Between 4GB and 16GB in 1GB increments
      # 4096 (4 vCPU) - Available memory values: Between 8GB and 30GB in 1GB increments
      Cpu: 256
      # 0.5GB, 1GB, 2GB - Available cpu values: 256 (.25 vCPU)
      # 1GB, 2GB, 3GB, 4GB - Available cpu values: 512 (.5 vCPU)
      # 2GB, 3GB, 4GB, 5GB, 6GB, 7GB, 8GB - Available cpu values: 1024 (1 vCPU)
      # Between 4GB and 16GB in 1GB increments - Available cpu values: 2048 (2 vCPU)
      # Between 8GB and 30GB in 1GB increments - Available cpu values: 4096 (4 vCPU)
      Memory: 1GB
      # A role needed by ECS.
      # "The ARN of the task execution role that containers in this task can assume. All containers in this task are granted the permissions that are specified in this role."
      # "There is an optional task execution IAM role that you can specify with Fargate to allow your Fargate tasks to make API calls to Amazon ECR."
      ExecutionRoleArn: !Ref ECSExecutionRole
      # "The Amazon Resource Name (ARN) of an AWS Identity and Access Management (IAM) role that grants containers in the task permission to call AWS APIs on your behalf."
      TaskRoleArn: !Ref ECSTaskRole
      ContainerDefinitions:
        - Name: !Join [ '-', [ !Ref APIName, djangoCron-container ] ]
          Image: !Ref DjangoDockerImage
          EntryPoint:
            - "sh"
            - "-c"
            - "python manage.py crontab --no-heartbeat"
          WorkingDirectory: "/app"
          Environment:
            - Name: 'ENVIRONMENT'
              Value: !Ref Environment
            - Name: 'DATA_DB_NAME'
              Value: !Ref DBName
            - Name: 'DATA_DB_USER'
              Value: !Ref DBUsername
            - Name: 'DATA_DB_HOST'
              Value: !Ref DBEndpoint
            - Name: 'DATA_DB_PORT'
              Value: '5432'
            - Name: 'DATA_DB_CONN_MAX_AGE'
              Value: "0"
            - Name: 'DRAMATIQ_REDIS_HOST'
              Value: !Ref RedisHost
            - Name: 'DRAMATIQ_REDIS_PORT'
              Value: !Ref RedisPort
            - Name: 'DRAMATIQ_NAMESPACE'
              Value: !Ref APIName
            - Name: 'AUTH0_DOMAIN'
              Value: !Ref a0DomainName
            - Name: 'AUTH0_CUSTOM_DOMAIN'
              Value: !Ref a0CustomDomainName
            - Name: 'AUTH0_API_IDENTIFIER'
              Value: !Ref a0ApiIdentifier
            - Name: 'API_DOMAIN_NAME'
              Value: !Ref ApiFullDomainName
            - Name: 'APP_DOMAIN_NAME'
              Value: !Ref AppFullDomainName
            - Name: 'PLAID_ENV'
              Value: !Ref PlaidEnv
            - Name: 'ONESIGNAL_APP_ID'
              Value: !Ref OneSignalAppId
            - Name: 'ONESIGNAL_TWILIO_FROM_NUMBER'
              Value: !Ref OneSignalTwilioFromNumber
            - Name: 'TWILIO_VERIFY_SID'
              Value: !Ref TwilioVerifyServiceId
            - Name: 'SENTRY_ENV'
              Value: !Ref Environment
            - Name: 'TWILIO_FROM_NUMBER'
              Value: !Ref TwilioFromNumber
            - Name: 'COMET_CHAT_API_URL'
              Value: !Ref CometChatApiUrl
            - Name: 'SIGNWELL_API_APP_ID'
              Value: !Ref signWellAPIAppId
            - Name: 'TREASURY_PRIME_API_ENDPOINT'
              Value: !Ref treasuryPrimeApiEndpoint
          Secrets:
            - Name: 'DATA_DB_PASSWORD'
              ValueFrom: !Sub '${DjangoAWSSecretArn}:DJANGO_DATA_DB_PASSWORD::'
            - Name: 'AUTH0_MANAGEMENT_CLIENT_SECRET'
              ValueFrom: !Sub '${DjangoAWSSecretArn}:AUTH0_MANAGEMENT_CLIENT_SECRET::'
            - Name: 'AUTH0_MANAGEMENT_CLIENT_ID'
              ValueFrom: !Sub '${DjangoAWSSecretArn}:AUTH0_MANAGEMENT_CLIENT_ID::'
            - Name: 'PLAID_CLIENT_ID'
              ValueFrom: !Sub '${DjangoAWSSecretArn}:PLAID_CLIENT_ID::'
            - Name: 'PLAID_SECRET'
              ValueFrom: !Sub '${DjangoAWSSecretArn}:PLAID_SECRET::'
            - Name: 'ONESIGNAL_API_KEY'
              ValueFrom: !Sub '${DjangoAWSSecretArn}:ONESIGNAL_API_KEY::'
            - Name: 'TWILIO_AUTH_TOKEN'
              ValueFrom: !Sub '${DjangoAWSSecretArn}:TWILIO_AUTH_TOKEN::'
            - Name: 'TWILIO_ACCOUNT_SID'
              ValueFrom: !Sub '${DjangoAWSSecretArn}:TWILIO_ACCOUNT_SID::'
            - Name: 'SENDGRID_API_KEY'
              ValueFrom: !Sub '${DjangoAWSSecretArn}:SENDGRID_API_KEY::'
            - Name: 'SENTRY_DSN'
              ValueFrom: !Sub '${DjangoAWSSecretArn}:SENTRY_DSN::'
            - Name: 'DJANGO_SECRET_KEY'
              ValueFrom: !Sub '${DjangoAWSSecretArn}:DJANGO_SECRET_KEY::'
            - Name: 'COMET_CHAT_REST_KEY'
              ValueFrom: !Sub '${DjangoAWSSecretArn}:COMET_CHAT_REST_KEY::'
            - Name: 'STRIPE_API_KEY'
              ValueFrom: !Sub '${DjangoAWSSecretArn}:STRIPE_API_KEY::'
            - Name: 'STRIPE_PUBLISHABLE_KEY'
              ValueFrom: !Sub '${DjangoAWSSecretArn}:STRIPE_PUBLISHABLE_KEY::'
            - Name: 'SIGNWELL_API_KEY'
              ValueFrom: !Sub '${DjangoAWSSecretArn}:SIGNWELL_API_KEY::'
            - Name: 'SIGNWELL_WEBHOOK_KEY'
              ValueFrom: !Sub '${DjangoAWSSecretArn}:SIGNWELL_WEBHOOK_KEY::'
            - Name: 'TREASURY_PRIME_API_KEY_ID'
              ValueFrom: !Sub '${DjangoAWSSecretArn}:TREASURY_PRIME_API_KEY_ID::'
            - Name: 'TREASURY_PRIME_API_SECRET_KEY'
              ValueFrom: !Sub '${DjangoAWSSecretArn}:TREASURY_PRIME_API_SECRET_KEY::'
            - Name: 'TREASURY_PRIME_WEBHOOK_USERNAME'
              ValueFrom: !Sub '${DjangoAWSSecretArn}:TREASURY_PRIME_WEBHOOK_USERNAME::'
            - Name: 'TREASURY_PRIME_WEBHOOK_PASSWORD'
              ValueFrom: !Sub '${DjangoAWSSecretArn}:TREASURY_PRIME_WEBHOOK_PASSWORD::'
            - Name: 'HASURA_GRAPHQL_ADMIN_SECRET'
              ValueFrom: !Sub '${HasuraAWSSecretArn}:HASURA_GRAPHQL_ADMIN_SECRET::'

          # Send logs to CloudWatch Logs
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-region: !Ref AWS::Region
              awslogs-group: !Ref DjangoLogGroup
              awslogs-stream-prefix: ecs

  DjangoTargetGroup:
    Type: 'AWS::ElasticLoadBalancingV2::TargetGroup'
    Properties:
      Name: !Join [ '-', [ !Ref APIName, djtg ] ]
      Port: !FindInMap [ ALL,  Ports,  DjangoContainerPort ]
      Protocol: HTTP
      HealthCheckIntervalSeconds: 30
      # will look for a 200 status code by default unless specified otherwise
      HealthCheckProtocol: HTTP
      HealthCheckPath: "/healthz"
      HealthCheckTimeoutSeconds: 5
      UnhealthyThresholdCount: 2
      HealthyThresholdCount: 2
      TargetGroupAttributes:
        - Key: deregistration_delay.timeout_seconds
          Value: 60 # default is 300
      TargetType: ip
      VpcId: !Ref VpcId

  DjangoAPIECSService:
    Type: AWS::ECS::Service
    DependsOn:
      - AppLoadBalancer
      - DjangoListenerRuleHTTPS
      - DjangoTargetGroup
    Properties:
      Cluster: !Ref ECSCluster
      TaskDefinition: !Ref DjangoAPITaskDefinition
      ServiceName: !Join [ '-', [ !Ref APIName, djangoApi ] ]
      SchedulingStrategy: REPLICA
      DesiredCount: 1
      LaunchType: FARGATE
      LoadBalancers:
        - ContainerName: !Join [ '-', [ !Ref APIName, djangoApi-container ] ]
          ContainerPort: !FindInMap [ ALL,  Ports,  DjangoContainerPort ]
          TargetGroupArn: !Ref DjangoTargetGroup

      NetworkConfiguration:
        AwsvpcConfiguration:
          # change to DISABLED if you're using private subnets that have access to a NAT gateway
          AssignPublicIp: DISABLED
          Subnets:
            - !Ref 'VpcPrivateSubnetA'
            - !Ref 'VpcPrivateSubnetB'
          SecurityGroups:
            - !Ref 'EC2SecurityGroup'
      PlatformVersion: LATEST
      DeploymentConfiguration:
        MaximumPercent: 200
        MinimumHealthyPercent: 100
        DeploymentCircuitBreaker:
          Enable: false
          Rollback: false
      DeploymentController:
        Type: ECS
      EnableECSManagedTags: true
      ServiceConnectConfiguration:
        Enabled: false
      ServiceRegistries:
        - RegistryArn: !GetAtt DjangoSDService.Arn
          ContainerName: !Join [ '-', [ !Ref APIName, djangoApi-container ] ]

  DjangoDMTQECSService:
    Type: AWS::ECS::Service
    DependsOn:
      - AppLoadBalancer
      - DjangoListenerRuleHTTPS
      - DjangoTargetGroup
    Properties:
      Cluster: !Ref ECSCluster
      TaskDefinition: !Ref DjangoDMTQTaskDefinition
      ServiceName: !Join [ '-', [ !Ref APIName, djangoDMTQ ] ]
      SchedulingStrategy: REPLICA
      DesiredCount: 1
      LaunchType: FARGATE
      NetworkConfiguration:
        AwsvpcConfiguration:
          # change to DISABLED if you're using private subnets that have access to a NAT gateway
          AssignPublicIp: DISABLED
          Subnets:
            - !Ref 'VpcPrivateSubnetA'
            - !Ref 'VpcPrivateSubnetB'
          SecurityGroups:
            - !Ref 'EC2SecurityGroup'
      PlatformVersion: LATEST
      DeploymentConfiguration:
        MaximumPercent: 200
        MinimumHealthyPercent: 100
        DeploymentCircuitBreaker:
          Enable: false
          Rollback: false
      DeploymentController:
        Type: ECS
      EnableECSManagedTags: true
      ServiceConnectConfiguration:
        Enabled: false

  DjangoCronECSService:
    Type: AWS::ECS::Service
    DependsOn:
      - AppLoadBalancer
      - DjangoListenerRuleHTTPS
      - DjangoTargetGroup
    Properties:
      Cluster: !Ref ECSCluster
      TaskDefinition: !Ref DjangoCronTaskDefinition
      ServiceName: !Join [ '-', [ !Ref APIName, djangoCron ] ]
      SchedulingStrategy: REPLICA
      DesiredCount: 1
      LaunchType: FARGATE
      NetworkConfiguration:
        AwsvpcConfiguration:
          # change to DISABLED if you're using private subnets that have access to a NAT gateway
          AssignPublicIp: DISABLED
          Subnets:
            - !Ref 'VpcPrivateSubnetA'
            - !Ref 'VpcPrivateSubnetB'
          SecurityGroups:
            - !Ref 'EC2SecurityGroup'
      PlatformVersion: LATEST
      DeploymentConfiguration:
        MaximumPercent: 100
        MinimumHealthyPercent: 0
        DeploymentCircuitBreaker:
          Enable: false
          Rollback: false
      DeploymentController:
        Type: ECS
      EnableECSManagedTags: true
      ServiceConnectConfiguration:
        Enabled: false

  # punch SG to allow access to RDS from ECS
  SecurityGroupRDSIngress:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !Ref RDSSecurityGroupID
      IpProtocol: "tcp"
      ToPort: "5432"
      FromPort: "5432"
      SourceSecurityGroupId: !GetAtt EC2SecurityGroup.GroupId

  # punch SG to allow access to Redis from ECS
  SecurityGroupRedisIngress:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !Ref RedisSecurityGroupID
      IpProtocol: "tcp"
      ToPort: "6379"
      FromPort: "6379"
      SourceSecurityGroupId: !GetAtt EC2SecurityGroup.GroupId


  # The Amazon S3 bucket into which access logs from S3 (for the application) and CloudFront will be put
  LoggingBucket:
    #checkov:skip=CKV_AWS_18: "This bucket is private and only for storing logs"
    Type: AWS::S3::Bucket
    Properties:
      BucketName:
        'Fn::Transform':
          Name: 'String'
          Parameters:
            InputString: !Sub 'react-cors-spa-${APIName}-logs'
            Operation: Lower

      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      VersioningConfiguration:
        Status: Enabled
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: 'AES256'
      OwnershipControls:
        Rules:
          - ObjectOwnership: BucketOwnerPreferred
    DeletionPolicy: Delete

  # The Amazon S3 bucket into which our Single Page Application build files must be deployed
  S3Bucket:
    Type: AWS::S3::Bucket
    DeletionPolicy: Delete
    Properties:
      BucketName:
        'Fn::Transform':
          Name: 'String'
          Parameters:
            InputString: !Sub 'react-cors-spa-${APIName}'
            Operation: Lower

      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      LoggingConfiguration:
        DestinationBucketName: !Ref LoggingBucket
        LogFilePrefix: s3-access-logs
      VersioningConfiguration:
        Status: Enabled
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: 'AES256'

  # The Amazon S3 bucket policy for securing the bucket hosting the application
  BucketPolicy:
    Type: 'AWS::S3::BucketPolicy'
    Properties:
      PolicyDocument:
        Id: MyPolicy
        Version: 2012-10-17
        Statement:
          - Sid: PolicyForCloudFrontPrivateContent
            Effect: Allow
            Resource: !Sub ${S3Bucket.Arn}/*
            Principal:
              Service: cloudfront.amazonaws.com
            Condition:
              StringEquals:
                AWS:SourceArn: !Sub arn:aws:cloudfront::${AWS::AccountId}:distribution/${CFDistribution}
            Action: 's3:GetObject*'
      Bucket: !Ref S3Bucket

  # The Amazon CloudFront distribution exposing our Single Page Application
  CFDistribution:
    #checkov:skip=CKV_AWS_68: "For demo purposes and to reduce cost, no WAF is configured"
    Type: AWS::CloudFront::Distribution
    Properties:
      DistributionConfig:
        Origins:
          - DomainName: !GetAtt S3Bucket.RegionalDomainName
            Id: !Sub "${APIName}S3Origin"
            S3OriginConfig:
              OriginAccessIdentity: ""
            OriginAccessControlId: !GetAtt CloudFrontOriginAccessControl.Id
        Aliases:
          - !Ref AppFullDomainName
        ViewerCertificate:
          AcmCertificateArn: !Ref APPCertificateARN
          SslSupportMethod: sni-only
        Enabled: 'true'
        DefaultRootObject: index.html
        CustomErrorResponses:
          - ErrorCode: 403
            ResponseCode: 200
            ResponsePagePath: "/index.html"
          - ErrorCode: 404
            ResponseCode: 200
            ResponsePagePath: "/index.html"
        DefaultCacheBehavior:
          AllowedMethods:
            - GET
            - HEAD
            - OPTIONS
          TargetOriginId: !Sub "${APIName}S3Origin"
          CachePolicyId: 658327ea-f89d-4fab-a63d-7e88639e58f6 # CachingOptimized
          Compress: true
          OriginRequestPolicyId: 88a5eaf4-2fd4-4709-b370-b4c650ea3fcf # CORS-S3Origin
          ResponseHeadersPolicyId: 67f7725c-6f97-4210-82d7-5512b31e9d03 # SecurityHeadersPolicy
          ViewerProtocolPolicy: redirect-to-https
        PriceClass: PriceClass_All
        Logging:
          Bucket: !GetAtt LoggingBucket.RegionalDomainName
          Prefix: 'cloudfront-access-logs'

  # The Amazon CloudFront origin access control
  CloudFrontOriginAccessControl:
    Type: AWS::CloudFront::OriginAccessControl
    DependsOn:
      - S3Bucket
    Properties:
      OriginAccessControlConfig:
        Description: Default Origin Access Control
        Name: !Ref AWS::StackName
        OriginAccessControlOriginType: s3
        SigningBehavior: always
        SigningProtocol: sigv4

  APPDNSName:
    Type: AWS::Route53::RecordSetGroup
    Properties:
      HostedZoneName: !Join [ '', [ !Ref 'DomainName', . ] ]
      RecordSets:
        - Name: !Ref AppFullDomainName
          Type: A
          AliasTarget:
            HostedZoneId: "Z2FDTNDATAQYW2" # special CloudFront distribution value
            DNSName: !GetAtt CFDistribution.DomainName

  APIDNSName:
    Type: AWS::Route53::RecordSetGroup
    Properties:
      HostedZoneName: !Join [ '', [ !Ref 'DomainName', . ] ]
      RecordSets:
        - Name: !Ref ApiFullDomainName
          Type: A
          AliasTarget:
            HostedZoneId: !GetAtt AppLoadBalancer.CanonicalHostedZoneID
            DNSName: !GetAtt AppLoadBalancer.DNSName

  StorageS3Bucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName:
        'Fn::Transform':
          Name: 'String'
          Parameters:
            InputString: !Sub 'storage-private-${APIName}'
            Operation: Lower

      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      VersioningConfiguration:
        Status: Suspended
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - BucketKeyEnabled: True
            ServerSideEncryptionByDefault:
              SSEAlgorithm: 'AES256'
      OwnershipControls:
        Rules:
          - ObjectOwnership: BucketOwnerPreferred
    DeletionPolicy: Delete

  StorageAPILogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Join [ '', [ /ecs/, !Ref APIName, StorageAPITaskDefinition ] ]

  StorageAPITaskDefinition:
    Type: AWS::ECS::TaskDefinition
    # Makes sure the log group is created before it is used.
    DependsOn: StorageAPILogGroup
    Properties:
      # Name of the task definition. Subsequent versions of the task definition are grouped together under this name.
      Family: !Join [ '-', [ !Ref APIName, StorageAPITaskDef ] ]
      # awsvpc is required for Fargate
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - FARGATE
      # 256 (.25 vCPU) - Available memory values: 0.5GB, 1GB, 2GB
      # 512 (.5 vCPU) - Available memory values: 1GB, 2GB, 3GB, 4GB
      # 1024 (1 vCPU) - Available memory values: 2GB, 3GB, 4GB, 5GB, 6GB, 7GB, 8GB
      # 2048 (2 vCPU) - Available memory values: Between 4GB and 16GB in 1GB increments
      # 4096 (4 vCPU) - Available memory values: Between 8GB and 30GB in 1GB increments
      Cpu: 256  # should be more than enough for a io based service
      # 0.5GB, 1GB, 2GB - Available cpu values: 256 (.25 vCPU)
      # 1GB, 2GB, 3GB, 4GB - Available cpu values: 512 (.5 vCPU)
      # 2GB, 3GB, 4GB, 5GB, 6GB, 7GB, 8GB - Available cpu values: 1024 (1 vCPU)
      # Between 4GB and 16GB in 1GB increments - Available cpu values: 2048 (2 vCPU)
      # Between 8GB and 30GB in 1GB increments - Available cpu values: 4096 (4 vCPU)
      Memory: 0.5GB
      # A role needed by ECS.
      # "The ARN of the task execution role that containers in this task can assume. All containers in this task are granted the permissions that are specified in this role."
      # "There is an optional task execution IAM role that you can specify with Fargate to allow your Fargate tasks to make API calls to Amazon ECR."
      ExecutionRoleArn: !Ref ECSExecutionRole
      # "The Amazon Resource Name (ARN) of an AWS Identity and Access Management (IAM) role that grants containers in the task permission to call AWS APIs on your behalf."
      TaskRoleArn: !Ref ECSTaskRole
      ContainerDefinitions:
        - Name: !Join [ '-', [ !Ref APIName, storageApi-container ] ]
          Image: !Ref StorageDockerImage
          Command:
            - "serve"
          PortMappings:
            - ContainerPort: !FindInMap [ ALL,  Ports,  StorageContainerPort ]
              Name: storageapi
              AppProtocol: http
          # Send logs to CloudWatch Logs
          Environment:
            - Name: 'BIND'
              Value: !Join [ '', [ ":", !FindInMap [ ALL,  Ports,  StorageContainerPort ] ] ]
            - Name: 'S3_ACCESS_KEY'
              Value: !Ref StorageS3UserAccessKey
            - Name: 'S3_SECRET_KEY'
              Value: !GetAtt StorageS3UserAccessKey.SecretAccessKey
            - Name: 'S3_REGION'
              Value: !Ref AWS::Region
            - Name: 'S3_BUCKET'
              Value: !Ref StorageS3Bucket
            - Name: 'HASURA_ENDPOINT'
              Value: !Join [
                '',
                [
                  'http://',
                  !Join [ '.', [ !GetAtt HasuraSDService.Name, !Ref APIName ] ],
                  ':',
                  !FindInMap [ ALL,  Ports,  HasuraContainerPort ],
                  '/v1',
                ],
              ]
            - Name: 'POSTGRES_MIGRATIONS'
              Value: "0"
            - Name: 'HASURA_METADATA'
              Value: "0"
            - Name: 'DEBUG'
              Value: "0"
            - Name: 'S3_ENDPOINT'
              Value: !Sub 'https://s3.${AWS::Region}.amazonaws.com'
            - Name: 'PUBLIC_URL'
              Value: !Sub 'https://${ApiFullDomainName}'
            - Name: 'HASURA_GRAPHQL_CORS_DOMAIN'
              Value: !Sub 'https://${AppFullDomainName},https://${ApiFullDomainName}'
          Secrets:
            - Name: 'HASURA_GRAPHQL_ADMIN_SECRET'
              ValueFrom: !Sub '${HasuraAWSSecretArn}:HASURA_GRAPHQL_ADMIN_SECRET::'
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-region: !Ref AWS::Region
              awslogs-group: !Ref StorageAPILogGroup
              awslogs-stream-prefix: ecs

  StorageTargetGroup:
    Type: 'AWS::ElasticLoadBalancingV2::TargetGroup'
    Properties:
      Name: !Join [ '-', [ !Ref APIName, storage-tg ] ]
      Port: !FindInMap [ ALL,  Ports,  StorageContainerPort ]
      Protocol: HTTP
      HealthCheckIntervalSeconds: 10
      # will look for a 200 status code by default unless specified otherwise
      HealthCheckProtocol: HTTP
      HealthCheckPath: "/healthz"
      HealthCheckTimeoutSeconds: 5
      UnhealthyThresholdCount: 2
      HealthyThresholdCount: 2
      TargetGroupAttributes:
        - Key: deregistration_delay.timeout_seconds
          Value: 60 # default is 300
      TargetType: ip
      VpcId: !Ref VpcId

  StorageListenerRuleHTTPS:
    Type: AWS::ElasticLoadBalancingV2::ListenerRule
    Properties:
      Actions:
        - Type: forward
          TargetGroupArn: !Ref StorageTargetGroup
      Conditions:
        - Field: path-pattern
          Values:
            - "/v1/files/*"
            - "/v1/ops/*"
      ListenerArn: !Ref ALBListenerHTTPS
      Priority: 2

  StorageAPIECSService:
    Type: AWS::ECS::Service
    DependsOn:
      - AppLoadBalancer
      - StorageListenerRuleHTTPS
      - StorageTargetGroup
    Properties:
      Cluster: !Ref ECSCluster
      TaskDefinition: !Ref StorageAPITaskDefinition
      ServiceName: !Join [ '-', [ !Ref APIName, storageApi ] ]
      SchedulingStrategy: REPLICA
      DesiredCount: 1
      LaunchType: FARGATE
      LoadBalancers:
        - ContainerName: !Join [ '-', [ !Ref APIName, storageApi-container ] ]
          ContainerPort: !FindInMap [ ALL,  Ports,  StorageContainerPort ]
          TargetGroupArn: !Ref StorageTargetGroup

      NetworkConfiguration:
        AwsvpcConfiguration:
          # change to DISABLED if you're using private subnets that have access to a NAT gateway
          AssignPublicIp: DISABLED
          Subnets:
            - !Ref 'VpcPrivateSubnetA'
            - !Ref 'VpcPrivateSubnetB'
          SecurityGroups:
            - !Ref 'EC2SecurityGroup'
      PlatformVersion: LATEST
      DeploymentConfiguration:
        MaximumPercent: 200
        MinimumHealthyPercent: 100
        DeploymentCircuitBreaker:
          Enable: false
          Rollback: false
      DeploymentController:
        Type: ECS
      EnableECSManagedTags: true
      ServiceConnectConfiguration:
        Enabled: false
      ServiceRegistries:
        - RegistryArn: !GetAtt StorageSDService.Arn
          ContainerName: !Join [ '-', [ !Ref APIName, storageApi-container ] ]

  StorageS3User:
    Type: AWS::IAM::User
    Properties:
      Policies:
        - PolicyName: bucket-access
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:*
                Resource:
                  - !Sub arn:aws:s3:::${StorageS3Bucket}
                  - !Sub arn:aws:s3:::${StorageS3Bucket}/*
  StorageS3UserAccessKey:
    Type: AWS::IAM::AccessKey
    Properties:
      UserName: !Ref StorageS3User

Outputs:
  AZA:
    Description: 'AZ of A'
    Value: !Select [ 0, !GetAZs '' ]
    Export:
      Name: !Sub '${AWS::StackName}-AZA'
  EC2SecurityGroupID:
    Description: 'The ID of the EC2 Security group'
    Value: !GetAtt EC2SecurityGroup.GroupId
    Export:
      Name: !Sub '${AWS::StackName}-EC2-ID'
